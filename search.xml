<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>使用Shiro 导致AOP切面失效</title>
      <link href="/2020/04/27/shiro-aop/"/>
      <url>/2020/04/27/shiro-aop/</url>
      
        <content type="html"><![CDATA[<blockquote><p>如题，当Springboot集成Shiro时。<br>Shiro认证ShiroRealm 中引入Service的同时，AOP对该Service有命中切面。会导致AOP失效</p><p>你若是找不到坚持下去的理由，那么你就找一个重新开始的理由，生活本来就这么简单。</p></blockquote><h5 id="AOP失效问题"><a href="#AOP失效问题" class="headerlink" title="AOP失效问题"></a>AOP失效问题</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyShiroRealm</span> <span class="keyword">extends</span> <span class="title">AuthorizingRealm</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    UserService userService;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="解决方法。"><a href="#解决方法。" class="headerlink" title="解决方法。"></a>解决方法。</h5><pre><code>网上说是Shiro与Aspect的冲突。给Shiro认证器单独写一个Service。 有别的解决方式，请联系我。共同进步。</code></pre>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>获取txt文档编码格式</title>
      <link href="/2019/09/19/%E8%8E%B7%E5%8F%96txt%E6%96%87%E6%A1%A3%E7%BC%96%E7%A0%81%E6%A0%BC%E5%BC%8F/"/>
      <url>/2019/09/19/%E8%8E%B7%E5%8F%96txt%E6%96%87%E6%A1%A3%E7%BC%96%E7%A0%81%E6%A0%BC%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=28708061&auto=1&height=66"></iframe><blockquote><p>网上好多不完全，总有个别txt的编码获取不到。<br>用这段代码，暂时没有发现问题。</p><p>它在我的机器上可以很好运行！  ——-大部分程序员</p></blockquote><h5 id="部分TXT识别不了的版本"><a href="#部分TXT识别不了的版本" class="headerlink" title="部分TXT识别不了的版本"></a>部分TXT识别不了的版本</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">InputStream inputStream = <span class="keyword">new</span> FileInputStream(<span class="string">"g62.txt"</span>);</span><br><span class="line"><span class="keyword">byte</span>[] head = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">3</span>];</span><br><span class="line">inputStream.read(head);</span><br><span class="line">String code = <span class="string">"GBK"</span>;</span><br><span class="line"><span class="keyword">if</span> (head[<span class="number">0</span>] == -<span class="number">1</span>  &amp;&amp;  head[<span class="number">1</span>] == -<span class="number">2</span>)&#123;</span><br><span class="line">    code = <span class="string">"UTF-16"</span>;</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span> (head[<span class="number">0</span>] == -<span class="number">2</span>  &amp;&amp;  head[<span class="number">1</span>] == -<span class="number">1</span>)&#123;</span><br><span class="line">    code = <span class="string">"Unicode"</span>;</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span> (head[<span class="number">0</span>] == -<span class="number">17</span>  &amp;&amp; head[<span class="number">1</span>] == -<span class="number">69</span> &amp;&amp; head[<span class="number">2</span>] == -<span class="number">65</span>)&#123;</span><br><span class="line">    code = <span class="string">"UTF-8"</span>;</span><br><span class="line">&#125;</span><br><span class="line">inputStream.close();</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">BufferedInputStream bin = <span class="keyword">new</span> BufferedInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">"62.txt"</span>));</span><br><span class="line"><span class="keyword">int</span> p = (bin.read() &lt;&lt; <span class="number">8</span>) + bin.read();</span><br><span class="line"></span><br><span class="line">String code = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> (p) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0xefbb</span>:</span><br><span class="line">        code = <span class="string">"UTF-8"</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0xfffe</span>:</span><br><span class="line">        code = <span class="string">"Unicode"</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0xfeff</span>:</span><br><span class="line">        code = <span class="string">"UTF-16BE"</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        code = <span class="string">"GBK"</span>;</span><br><span class="line">&#125;</span><br><span class="line">bin.close();</span><br></pre></td></tr></table></figure><h5 id="未发现问题版本"><a href="#未发现问题版本" class="headerlink" title="未发现问题版本"></a>未发现问题版本</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span>  String <span class="title">getFileCharset</span><span class="params">(File sourceFile)</span> </span>&#123;</span><br><span class="line">    String charset = <span class="string">"GBK"</span>;</span><br><span class="line">    <span class="keyword">byte</span>[] first3Bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">3</span>];</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">boolean</span> checked = <span class="keyword">false</span>;</span><br><span class="line">        BufferedInputStream bis = <span class="keyword">new</span> BufferedInputStream(<span class="keyword">new</span> FileInputStream(sourceFile));</span><br><span class="line">        bis.mark(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">int</span> read = bis.read(first3Bytes, <span class="number">0</span>, <span class="number">3</span>);</span><br><span class="line">        <span class="keyword">if</span> (read == -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> charset; <span class="comment">//文件编码为 ANSI</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (first3Bytes[<span class="number">0</span>] == (<span class="keyword">byte</span>) <span class="number">0xFF</span></span><br><span class="line">                &amp;&amp; first3Bytes[<span class="number">1</span>] == (<span class="keyword">byte</span>) <span class="number">0xFE</span>) &#123;</span><br><span class="line">            charset = <span class="string">"UTF-16LE"</span>; <span class="comment">//文件编码为 Unicode</span></span><br><span class="line">            checked = <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (first3Bytes[<span class="number">0</span>] == (<span class="keyword">byte</span>) <span class="number">0xFE</span></span><br><span class="line">                &amp;&amp; first3Bytes[<span class="number">1</span>] == (<span class="keyword">byte</span>) <span class="number">0xFF</span>) &#123;</span><br><span class="line">            charset = <span class="string">"UTF-16BE"</span>; <span class="comment">//文件编码为 Unicode big endian</span></span><br><span class="line">            checked = <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (first3Bytes[<span class="number">0</span>] == (<span class="keyword">byte</span>) <span class="number">0xEF</span></span><br><span class="line">                &amp;&amp; first3Bytes[<span class="number">1</span>] == (<span class="keyword">byte</span>) <span class="number">0xBB</span></span><br><span class="line">                &amp;&amp; first3Bytes[<span class="number">2</span>] == (<span class="keyword">byte</span>) <span class="number">0xBF</span>) &#123;</span><br><span class="line">            charset = <span class="string">"UTF-8"</span>; <span class="comment">//文件编码为 UTF-8</span></span><br><span class="line">            checked = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        bis.reset();</span><br><span class="line">        <span class="keyword">if</span> (!checked) &#123;</span><br><span class="line">            <span class="keyword">int</span> loc = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> ((read = bis.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">                loc++;</span><br><span class="line">                <span class="keyword">if</span> (read &gt;= <span class="number">0xF0</span>)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">if</span> (<span class="number">0x80</span> &lt;= read &amp;&amp; read &lt;= <span class="number">0xBF</span>) <span class="comment">// 单独出现BF以下的，也算是GBK</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">if</span> (<span class="number">0xC0</span> &lt;= read &amp;&amp; read &lt;= <span class="number">0xDF</span>) &#123;</span><br><span class="line">                    read = bis.read();</span><br><span class="line">                    <span class="keyword">if</span> (<span class="number">0x80</span> &lt;= read &amp;&amp; read &lt;= <span class="number">0xBF</span>) <span class="comment">// 双字节 (0xC0 - 0xDF)</span></span><br><span class="line">                        <span class="comment">// (0x80</span></span><br><span class="line">                        <span class="comment">// - 0xBF),也可能在GB编码内</span></span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="number">0xE0</span> &lt;= read &amp;&amp; read &lt;= <span class="number">0xEF</span>) &#123;<span class="comment">// 也有可能出错，但是几率较小</span></span><br><span class="line">                    read = bis.read();</span><br><span class="line">                    <span class="keyword">if</span> (<span class="number">0x80</span> &lt;= read &amp;&amp; read &lt;= <span class="number">0xBF</span>) &#123;</span><br><span class="line">                        read = bis.read();</span><br><span class="line">                        <span class="keyword">if</span> (<span class="number">0x80</span> &lt;= read &amp;&amp; read &lt;= <span class="number">0xBF</span>) &#123;</span><br><span class="line">                            charset = <span class="string">"UTF-8"</span>;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125; <span class="keyword">else</span></span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span></span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        bis.close();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> charset;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux LVM 管理同一目录挂在多块磁盘</title>
      <link href="/2019/06/06/Linex-LVM-%E7%AE%A1%E7%90%86%E5%90%8C%E4%B8%80%E7%9B%AE%E5%BD%95%E6%8C%82%E5%9C%A8%E5%A4%9A%E5%9D%97%E7%A3%81%E7%9B%98/"/>
      <url>/2019/06/06/Linex-LVM-%E7%AE%A1%E7%90%86%E5%90%8C%E4%B8%80%E7%9B%AE%E5%BD%95%E6%8C%82%E5%9C%A8%E5%A4%9A%E5%9D%97%E7%A3%81%E7%9B%98/</url>
      
        <content type="html"><![CDATA[<p><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=470759757&auto=1&height=66"></iframe><br><blockquote><p>遇到FastDFS文件服务器挂载盘会不够，就上网搜了一下挂载多块磁盘。</p></blockquote></p><h5 id="如果想操作的挂载盘已挂载，则先卸载。"><a href="#如果想操作的挂载盘已挂载，则先卸载。" class="headerlink" title="如果想操作的挂载盘已挂载，则先卸载。"></a>如果想操作的挂载盘已挂载，则先卸载。</h5><pre><code>umount -v /dev/data2umount -v /dev/data1</code></pre><h5 id="创建PV-物理卷"><a href="#创建PV-物理卷" class="headerlink" title="创建PV - 物理卷"></a>创建PV - 物理卷</h5><pre><code>pvcreate /dev/sdb1pvcreate /dev/sdc1pvscan</code></pre><h5 id="创建VG-卷组"><a href="#创建VG-卷组" class="headerlink" title="创建VG - 卷组"></a>创建VG - 卷组</h5><pre><code>创建卷组并命名  vgfast 可自行修改vgcreate vgfast /dev/sdb1 添加盘 给卷组添加盘vgextend vgfast /dev/sdc1</code></pre><h5 id="查看卷组"><a href="#查看卷组" class="headerlink" title="查看卷组"></a>查看卷组</h5><pre><code>vgs</code></pre><h5 id="创建逻辑卷-LV"><a href="#创建逻辑卷-LV" class="headerlink" title="创建逻辑卷 - LV"></a>创建逻辑卷 - LV</h5><pre><code>lvcreate -L 2.1T -n lvfast vgfast </code></pre><h5 id="格式化逻辑卷"><a href="#格式化逻辑卷" class="headerlink" title="格式化逻辑卷"></a>格式化逻辑卷</h5><pre><code>mkfs.ext4 /dev/vgdata/lvData  //格式化lvData为ext4格式。</code></pre><h5 id="挂载目录"><a href="#挂载目录" class="headerlink" title="挂载目录"></a>挂载目录</h5><pre><code>mount /dev/vgfast/lvfast /fastdfs/</code></pre>]]></content>
      
      
      <categories>
          
          <category> CentOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CentOS 管理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Solr集群安装</title>
      <link href="/2019/04/19/Solr%E9%9B%86%E7%BE%A4%E5%AE%89%E8%A3%85/"/>
      <url>/2019/04/19/Solr%E9%9B%86%E7%BE%A4%E5%AE%89%E8%A3%85/</url>
      
        <content type="html"><![CDATA[<h4 id="安装环境，集群部署"><a href="#安装环境，集群部署" class="headerlink" title="安装环境，集群部署"></a>安装环境，集群部署</h4><table><thead><tr><th>IP</th><th style="text-align:center">节点名称</th><th style="text-align:center">Zookeeper</th><th style="text-align:center">Solr</th></tr></thead><tbody><tr><td>192.168.100.21</td><td style="text-align:center">hadoop5</td><td style="text-align:center">zookeeper-3.4.14</td><td style="text-align:center">solr-7.7.1.tgz</td></tr><tr><td>192.168.100.22</td><td style="text-align:center">hadoop6</td><td style="text-align:center">zookeeper-3.4.14</td><td style="text-align:center">solr-7.7.1.tgz</td></tr><tr><td>192.168.100.23</td><td style="text-align:center">hadoop7</td><td style="text-align:center">zookeeper-3.4.14</td><td style="text-align:center">solr-7.7.1.tgz</td></tr></tbody></table><h4 id="解压安装包，运行安装脚本"><a href="#解压安装包，运行安装脚本" class="headerlink" title="解压安装包，运行安装脚本"></a>解压安装包，运行安装脚本</h4><ol><li>tar -zxvf solr-7.7.1.tgz</li><li><p>tar zxf solr-7.7.1.tgz solr-7.7.1/bin/install_solr_service.sh –strip-components=2</p><pre><code>上一个命令将install_solr_service.sh脚本从存档中提取到当前目录中mkdir /opt/module/solr2 mkdir /opt/module/solr</code></pre></li><li><p>运行服务安装脚本:</p><pre><code>bash ./install_solr_service.sh solr-7.7.1.tgz -i /opt/module/solr -d /opt/module/solr/solrhome -u solr -s solr -p 8983bash ./install_solr_service.sh solr-7.7.1.tgz -i /opt/module/solr2 -d /opt/module/solr2/solrhome -u solr -s solr2 -p 8984</code></pre></li><li><p>修改对应jetty服务的端口8983/8984</p><pre><code>vi  /opt/module/solr/solrhome/data/solr.xml vi  /opt/module/solr2/solrhome/data/solr.xml vi  /opt/module/solr/solrhome/data/solr.xml vi  /opt/module/solr2/solrhome/data/solr.xml </code></pre><h4 id="配置zk启动优先级"><a href="#配置zk启动优先级" class="headerlink" title="配置zk启动优先级"></a>配置zk启动优先级</h4></li><li><p>zookeeper自动启动 : vi /etc/init.d/zookeeper</p><pre><code>#!/bin/bash#chkconfig:2345 20 90#description:zookeeper#processname:zookeeperexport JAVA_HOME=/opt/module/jdk1.8export ZOO_LOG_DIR=/opt/module/zookeeper-3.4.14/logscase $1 in        start) su root /opt/module/zookeeper-3.4.14/bin/zkServer.sh start;;        stop) su root /opt/module/zookeeper-3.4.14/bin/zkServer.sh stop;;        status) su root /opt/module/zookeeper-3.4.14/bin/zkServer.sh status;;        restart) su root /opt/module/zookeeper-3.4.14/bin/zkServer.sh restart;;        *) echo &quot;require start|stop|status|restart&quot; ;;esac</code></pre></li><li><p>chmod +x /etc/init.d/zookeeper</p></li><li>chkconfig –add zookeeper</li></ol><h4 id="关联solr集群与zk集群"><a href="#关联solr集群与zk集群" class="headerlink" title="关联solr集群与zk集群"></a>关联solr集群与zk集群</h4><ol><li>vi /etc/default/solr.in.sh</li><li><p>vi /etc/default/solr2.in.sh</p><pre><code>修改如下信息（对应主机host注意更改）：ZK_HOST=&quot;node21:2181,node22:2181,node23:2181/solr&quot;SOLR_HOST=&quot;192.168.100.21&quot;</code></pre></li><li><p>首次连接需要创建节点管理目录</p><pre><code>./solr/bin/solr zk mkroot /solr -z hadoop5:2181,hadoop6:2181,hadoop7:2181</code></pre></li><li><p>使用Solr的ZooKeeper CLI上传solr配置信息到zk节点 </p><pre><code>sh solr/solr-7.7.1/server/scripts/cloud-scripts/zkcli.sh -zkhost hadoop5:2181,hadoop6:2181,hadoop7:2181 -cmd upconfig -confdir /opt/module/solr/solr-7.7.1/server/solr/configsets/_default/conf -confname myconf</code></pre></li><li><p>重新启动</p><pre><code>service solr restartservice solr2 restart</code></pre><h4 id="配置solr集群的分片规则"><a href="#配置solr集群的分片规则" class="headerlink" title="配置solr集群的分片规则"></a>配置solr集群的分片规则</h4><p> ./solr/bin/solr create -c collection1 -n collection1 -shards 2 -replicationFactor 2 -p 8983 -force<br> ./solr2/bin/solr create -c collection2 -n collection2 -shards 2 -replicationFactor 2 -p 8984 -force</p><p> 删除操作<br>   ./solr/solr/bin/solr delete -c collection2 </p><p> 参数说明：</p><p> -c <name> 要创建的核心或集合的名称（必需）。</name></p><p> -n <configname> 配置名称，默认与核心或集合的名称相同。</configname></p><p> -p <port> 发送create命令的本地Solr实例的端口; 默认情况下，脚本会尝试通过查找正在运行的Solr实例来检测端口。</port></p><p> -s <shards> 要么 -shards 将集合拆分为的分片数，默认为1; 仅适用于Solr在SolrCloud模式下运行的情况。</shards></p><p> -rf <replicas> 要么 -replicationFactor 集合中每个文档的副本数。默认值为1（无复制）。</replicas></p><p> -force 如果尝试以“root”用户身份运行create，则脚本将退出并显示运行Solr或针对Solr的操作作为“root”的警告可能会导致问题。可以使用-force参数覆盖此警告。</p><p> -d <confdir> 配置目录。默认为_default。</confdir></p></li></ol><h4 id="ik中文分词器"><a href="#ik中文分词器" class="headerlink" title="ik中文分词器"></a>ik中文分词器</h4><ol><li><p>jar包复制到各个节点</p><pre><code>cp ikanalyzer-solr5/ik-analyzer-solr5-5.x.jar ikanalyzer-solr5/solr-analyzer-ik-5.1.0.jar /opt/module/solr/solr-7.7.1/server/solr-webapp/webapp/WEB-INF/lib/</code></pre></li><li><p>各个节点执行</p><pre><code>mkdir -p /opt/module/solr/solr-7.7.1/server/solr-webapp/webapp/WEB-INF/classescp ext.dic IKAnalyzer.cfg.xml stopword.dic /opt/module/solr2/solr-7.7.1/server/solr-webapp/webapp/WEB-INF/classes/</code></pre></li><li><p>更改配置文件</p><pre><code>vim /opt/module/solr/solr-7.7.1/server/solr/configsets/_default/conf/managed-schema&lt;!--IK中文分词器--&gt; &lt;fieldType name=&quot;text_ik&quot; class=&quot;solr.TextField&quot;&gt;          &lt;analyzer type=&quot;index&quot; useSmart=&quot;false&quot;            class=&quot;org.wltea.analyzer.lucene.IKAnalyzer&quot; /&gt;        &lt;analyzer type=&quot;query&quot; useSmart=&quot;true&quot;            class=&quot;org.wltea.analyzer.lucene.IKAnalyzer&quot; /&gt;&lt;/fieldType&gt;</code></pre></li><li><p>更新配置文件</p><pre><code>sh /opt/module/solr/solr-7.7.1/server/scripts/cloud-scripts/zkcli.sh -zkhost hadoop5:2181,hadoop6:2181,hadoop7:2181 -cmd upconfig -confdir /opt/module/solr/solr-7.7.1/server/solr/configsets/_default/conf/ -confname myconf</code></pre></li></ol><p>比如我们修改schema.xml配置文件之后，根本不用登录zookeeper删除原有文件，文件会自动覆盖，这里直接上传即可，命令如下：</p><pre><code>./server/scripts/cloud-scripts/zkcli.sh -zkhost localhost:2181 -cmd putfile /solr/configs/my_config/schema.xml ../configs/conf/schema.xml</code></pre><p>参数putfile指定配置文件在zookeeper上的绝对路径，这里注意是配置的路径，不是collection的路径，二者名称不相同，后面跟的是修改之后本地schema.xml配置文件的路径</p><p>重新加载配置文件</p><pre><code>http://localhost:8983/solr/admin/collections?action=RELOAD&amp;name=my_collection</code></pre>]]></content>
      
      
      <categories>
          
          <category> 安装教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Solr </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>微信支付签名jar包问题</title>
      <link href="/2019/04/19/%E5%BE%AE%E4%BF%A1%E6%94%AF%E4%BB%98%E7%AD%BE%E5%90%8Djar%E5%8C%85%E9%97%AE%E9%A2%98/"/>
      <url>/2019/04/19/%E5%BE%AE%E4%BF%A1%E6%94%AF%E4%BB%98%E7%AD%BE%E5%90%8Djar%E5%8C%85%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p>#####针对jdk1.8.44以上版本</p><pre><code>将jre/lib/security/java.security文件中的将 #crypto.policy=unlimited改为 crypto.policy=unlimited其他不变，也不需要其他权限jar</code></pre><p>######针对jdk1.8.44以下版本，<br>    将jre/lib/security/ 下 的 local_policy.jar和US_export_policy.jar替换为官方网站提供了JCE无限制权限策略文件的下载：<br>    JDK6的下载地址：<br>    <a href="http://www.oracle.com/technetwork/java/javase/downloads/jce-6-download-429243.html" target="_blank" rel="noopener">http://www.oracle.com/technetwork/java/javase/downloads/jce-6-download-429243.html</a><br>    JDK7的下载地址：<br>    <a href="http://www.oracle.com/technetwork/java/javase/downloads/jce-7-download-432124.html" target="_blank" rel="noopener">http://www.oracle.com/technetwork/java/javase/downloads/jce-7-download-432124.html</a><br>    JDK8的下载地址：<br>    <a href="http://www.oracle.com/technetwork/java/javase/downloads/jce8-download-2133166.html" target="_blank" rel="noopener">http://www.oracle.com/technetwork/java/javase/downloads/jce8-download-2133166.html</a></p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 微信支付 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Zookeeper集群搭建</title>
      <link href="/2019/04/19/Zookeeper%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA/"/>
      <url>/2019/04/19/Zookeeper%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA/</url>
      
        <content type="html"><![CDATA[<blockquote><p>为了用到Solr，记录一下Zookeeper 的集群配置。</p></blockquote><h3 id="下载地址"><a href="#下载地址" class="headerlink" title="下载地址"></a>下载地址</h3><pre><code>官网首页： https://zookeeper.apache.org/下载地址： http://mirror.bit.edu.cn/apache/zookeeper/</code></pre><h4 id="集群规划"><a href="#集群规划" class="headerlink" title="集群规划"></a>集群规划</h4><p>在hadoop5、hadoop6和hadoop7三个节点上部署Zookeeper，三个节点都已安装jdk。</p><table><thead><tr><th>IP</th><th style="text-align:center">节点名称</th><th style="text-align:center">Zookeeper</th></tr></thead><tbody><tr><td>192.168.100.21</td><td style="text-align:center">hadoop5</td><td style="text-align:center">zookeeper-3.4.14</td></tr><tr><td>192.168.100.22</td><td style="text-align:center">hadoop6</td><td style="text-align:center">zookeeper-3.4.14</td></tr><tr><td>192.168.100.23</td><td style="text-align:center">hadoop7</td><td style="text-align:center">zookeeper-3.4.14</td></tr></tbody></table><h4 id="解压安装"><a href="#解压安装" class="headerlink" title="解压安装"></a>解压安装</h4><pre><code>（1）解压zookeeper安装包到/opt/module/目录下[admin@node21 software]$ tar -zxvf zookeeper-3.4.14.tar.gz -C /opt/module/（2）在/opt/module/zookeeper-3.4.14/这个目录下创建Data[admin@node21 zookeeper-3.4.14]# mkdir  Data（3）重命名/opt/module/zookeeper-3.4.14/conf这个目录下的zoo_sample.cfg为zoo.cfg[admin@node21 conf]# mv zoo_sample.cfg zoo.cfg</code></pre><h4 id="配置zoo-cfg文件"><a href="#配置zoo-cfg文件" class="headerlink" title="配置zoo.cfg文件"></a>配置zoo.cfg文件</h4><pre><code>具体配置，修改dateDir,添加日志存放目录dataDir=/opt/module/zookeeper-3.4.14/DatadataLogDir=/opt/module/zookeeper-3.4.14/logs末尾增加如下配置server.1=node21:2888:3888server.2=node22:2888:3888server.3=node23:2888:3888</code></pre><h4 id="集群配置"><a href="#集群配置" class="headerlink" title="集群配置"></a>集群配置</h4><pre><code>（1）在/opt/module/zookeeper-3.4.14/Data目录下创建一个myid的文件[admin@node21 Data]# sudo touch myid（2）编辑myid文件， 在文件中添加与server对应的编号：如 1   [admin@node21 Data]# vi myid（3）拷贝配置好的zookeeper到其他机器上[admin@node21 module]# scp -r zookeeper-3.4.14/ admin@node22:/opt/module/[admin@node21 module]# scp -r zookeeper-3.4.14/ admin@node23:/opt/module/并分别修改node22，node23中myid文件中内容为2、3[admin@node22 Data]# echo 2 &gt; myid[admin@node23 Data]# echo 3 &gt; myid</code></pre><h4 id="启动集群"><a href="#启动集群" class="headerlink" title="启动集群"></a>启动集群</h4><pre><code>（1）分别启动zookeeper[admin@node21 zookeeper-3.4.14]# bin/zkServer.sh start[admin@node22 zookeeper-3.4.14]# bin/zkServer.sh start[admin@node23 zookeeper-3.4.14]# bin/zkServer.sh start（2）查看状态复制代码[admin@node21 zookeeper-3.4.14]# bin/zkServer.sh statusZooKeeper JMX enabled by defaultUsing config: /opt/module/zookeeper-3.4.14/bin/../conf/zoo.cfgMode: follower[admin@node22 zookeeper-3.4.14]# bin/zkServer.sh statusZooKeeper JMX enabled by defaultUsing config: /opt/module/zookeeper-3.4.14/bin/../conf/zoo.cfgMode: follower[admin@node23 zookeeper-3.4.14]# bin/zkServer.sh statusZooKeeper JMX enabled by defaultUsing config: /opt/module/zookeeper-3.4.14/bin/../conf/zoo.cfgMode: leader复制代码（3）停止zookeeper[admin@node21 zookeeper-3.4.14]$ bin/zkServer.sh stop</code></pre><h4 id="配置环境变量"><a href="#配置环境变量" class="headerlink" title="配置环境变量"></a>配置环境变量</h4><p>[admin@node21 zookeeper-3.4.14]$ sudo vi /etc/profile<br>export ZOOKEEPER_HOME=/opt/module/zookeeper-3.4.14<br>export PATH=$PATH:$ZOOKEEPER_HOME/bin</p><h4 id="zoo-cfg配置参数解读"><a href="#zoo-cfg配置参数解读" class="headerlink" title="zoo.cfg配置参数解读"></a>zoo.cfg配置参数解读</h4><p>Server.A=B:C:D。</p><p>A是一个数字，表示这个是第几号服务器；</p><p>B是这个服务器的ip地址；</p><p>C是这个服务器与集群中的Leader服务器交换信息的端口；</p><p>D是万一集群中的Leader服务器挂了，需要一个端口来重新进行选举，选出一个新的Leader，而这个端口就是用来执行选举时服务器相互通信的端口。</p><p>集群模式下配置一个文件myid，这个文件在dataDir目录下，这个文件里面有一个数据就是A的值，Zookeeper启动时读取此文件，拿到里面的数据与zoo.cfg里面的配置信息比较从而判断到底是哪个server。</p><p>1）tickTime=2000：通信心跳数</p><p>tickTime：通信心跳数，Zookeeper服务器心跳时间，单位毫秒</p><p>Zookeeper使用的基本时间，服务器之间或客户端与服务器之间维持心跳的时间间隔，也就是每个tickTime时间就会发送一个心跳，时间单位为毫秒。</p><p>它用于心跳机制，并且设置最小的session超时时间为两倍心跳时间。(session的最小超时时间是2*tickTime)</p><p>2）initLimit=10：LF初始通信时限</p><p>集群中的follower跟随者服务器(F)与leader领导者服务器(L)之间初始连接时能容忍的最多心跳数（tickTime的数量），用它来限定集群中的Zookeeper服务器连接到Leader的时限。</p><p>投票选举新leader的初始化时间</p><p>Follower在启动过程中，会从Leader同步所有最新数据，然后确定自己能够对外服务的起始状态。</p><p>Leader允许F在initLimit时间内完成这个工作。</p><p>3）syncLimit=5：LF同步通信时限</p><p>集群中Leader与Follower之间的最大响应时间单位，假如响应超过syncLimit * tickTime，</p><p>Leader认为Follwer死掉，从服务器列表中删除Follwer。</p><p>在运行过程中，Leader负责与ZK集群中所有机器进行通信，例如通过一些心跳检测机制，来检测机器的存活状态。</p><p>如果L发出心跳包在syncLimit之后，还没有从F那收到响应，那么就认为这个F已经不在线了。</p><p>4）dataDir：数据文件目录+数据持久化路径</p><p>保存内存数据库快照信息的位置，如果没有其他说明，更新的事务日志也保存到数据库。</p><p> 5）clientPort=2181：客户端连接端口</p><p>监听客户端连接的端口</p>]]></content>
      
      
      <categories>
          
          <category> 安装教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Zookeeper </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java面试基础题</title>
      <link href="/2019/04/16/Java%E9%9D%A2%E8%AF%95%E5%9F%BA%E7%A1%80%E9%A2%98/"/>
      <url>/2019/04/16/Java%E9%9D%A2%E8%AF%95%E5%9F%BA%E7%A1%80%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<blockquote><p>转自公众号：托尼的技术成长之路 </p></blockquote><h3 id="Java-基础"><a href="#Java-基础" class="headerlink" title="Java 基础"></a>Java 基础</h3><h5 id="1-JDK-和-JRE-有什么区别？"><a href="#1-JDK-和-JRE-有什么区别？" class="headerlink" title="1. JDK 和 JRE 有什么区别？"></a>1. JDK 和 JRE 有什么区别？</h5><p>JDK：Java Development Kit 的简称，Java 开发工具包，提供了 Java 的开发环境和运行环境。<br>JRE：Java Runtime Environment 的简称，Java 运行环境，为 Java 的运行提供了所需环境。<br>具体来说 JDK 其实包含了 JRE，同时还包含了编译 Java 源码的编译器 Javac，还包含了很多 Java 程序调试和分析的工具。简单来说：如果你需要运行 Java 程序，只需安装 JRE 就可以了，如果你需要编写 Java 程序，需要安装 JDK。</p><h5 id="2-和-equals-的区别是什么？"><a href="#2-和-equals-的区别是什么？" class="headerlink" title="2. == 和 equals 的区别是什么？"></a>2. == 和 equals 的区别是什么？</h5><p>== 解读</p><p>对于基本类型和引用类型 == 的作用效果是不同的，如下所示：</p><p>基本类型：比较的是值是否相同；<br>引用类型：比较的是引用是否相同；<br>代码示例：</p><pre><code>String x = &quot;string&quot;;String y = &quot;string&quot;;String z = new String(&quot;string&quot;);System.out.println(x==y); // trueSystem.out.println(x==z); // falseSystem.out.println(x.equals(y)); // trueSystem.out.println(x.equals(z)); // true</code></pre><p>代码解读：因为 x 和 y 指向的是同一个引用，所以 == 也是 true，而 new String()方法则重写开辟了内存空间，所以 == 结果为 false，而 equals 比较的一直是值，所以结果都为 true。</p><p>equals 解读</p><p>equals 本质上就是 ==，只不过 String 和 Integer 等重写了 equals 方法，把它变成了值比较。看下面的代码就明白了。</p><p>首先来看默认情况下 equals 比较一个有相同值的对象，代码如下：</p><pre><code>class Cat {    public Cat(String name) {        this.name = name;    }    private String name;    public String getName() {        return name;    }    public void setName(String name) {        this.name = name;    }}Cat c1 = new Cat(&quot;王磊&quot;);Cat c2 = new Cat(&quot;王磊&quot;);System.out.println(c1.equals(c2)); // false</code></pre><p>输出结果出乎我们的意料，竟然是 false？这是怎么回事，看了 equals 源码就知道了，源码如下：</p><pre><code>public boolean equals(Object obj) {        return (this == obj);}</code></pre><p>原来 equals 本质上就是 ==。</p><p>那问题来了，两个相同值的 String 对象，为什么返回的是 true？代码如下：</p><pre><code>String s1 = new String(&quot;老王&quot;);String s2 = new String(&quot;老王&quot;);System.out.println(s1.equals(s2)); // true</code></pre><p>同样的，当我们进入 String 的 equals 方法，找到了答案，代码如下：</p><pre><code>public boolean equals(Object anObject) {    if (this == anObject) {        return true;    }    if (anObject instanceof String) {        String anotherString = (String)anObject;        int n = value.length;        if (n == anotherString.value.length) {            char v1[] = value;            char v2[] = anotherString.value;            int i = 0;            while (n-- != 0) {                if (v1[i] != v2[i])                    return false;                i++;            }            return true;        }    }    return false;}</code></pre><p>原来是 String 重写了 Object 的 equals 方法，把引用比较改成了值比较。</p><p>总结 ：== 对于基本类型来说是值比较，对于引用类型来说是比较的是引用；而 equals 默认情况下是引用比较，只是很多类重新了 equals 方法，比如 String、Integer 等把它变成了值比较，所以一般情况下 equals 比较的是值是否相等。</p><h5 id="3-两个对象的-hashCode-相同，则-equals-也一定为-true，对吗？"><a href="#3-两个对象的-hashCode-相同，则-equals-也一定为-true，对吗？" class="headerlink" title="3. 两个对象的 hashCode() 相同，则 equals() 也一定为 true，对吗？"></a>3. 两个对象的 hashCode() 相同，则 equals() 也一定为 true，对吗？</h5><p>不对，两个对象的 hashCode() 相同，equals() 不一定 true。</p><p>代码示例：</p><pre><code>String str1 = &quot;通话&quot;;String str2 = &quot;重地&quot;;System. out. println(String. format(&quot;str1：%d | str2：%d&quot;,  str1. hashCode(),str2. hashCode()));System. out. println(str1. equals(str2));</code></pre><p>执行的结果：</p><pre><code>str1：1179395 | str2：1179395false</code></pre><p>代码解读：很显然“通话”和“重地”的 hashCode() 相同，然而 equals() 则为 false，因为在散列表中，hashCode() 相等即两个键值对的哈希值相等，然而哈希值相等，并不一定能得出键值对相等。</p><h5 id="4-final-在-Java-中有什么作用？"><a href="#4-final-在-Java-中有什么作用？" class="headerlink" title="4. final 在 Java 中有什么作用？"></a>4. final 在 Java 中有什么作用？</h5><p>final 修饰的类叫最终类，该类不能被继承。<br>final 修饰的方法不能被重写。<br>final 修饰的变量叫常量，常量必须初始化，初始化之后值就不能被修改。</p><h5 id="5-Java-中的-Math-round-1-5-等于多少？"><a href="#5-Java-中的-Math-round-1-5-等于多少？" class="headerlink" title="5. Java 中的 Math. round(-1. 5) 等于多少？"></a>5. Java 中的 Math. round(-1. 5) 等于多少？</h5><p>等于 -1，因为在数轴上取值时，中间值（0.5）向右取整，所以正 0.5 是往上取整，负 0.5 是直接舍弃。</p><h5 id="6-String-属于基础的数据类型吗？"><a href="#6-String-属于基础的数据类型吗？" class="headerlink" title="6. String 属于基础的数据类型吗？"></a>6. String 属于基础的数据类型吗？</h5><p>String 不属于基础类型，基础类型有 8 种：byte、boolean、char、short、int、float、long、double，而 String 属于对象。</p><h5 id="7-Java-中操作字符串都有哪些类？它们之间有什么区别？"><a href="#7-Java-中操作字符串都有哪些类？它们之间有什么区别？" class="headerlink" title="7. Java 中操作字符串都有哪些类？它们之间有什么区别？"></a>7. Java 中操作字符串都有哪些类？它们之间有什么区别？</h5><p>操作字符串的类有：String、StringBuffer、StringBuilder。</p><p>String 和 StringBuffer、StringBuilder 的区别在于 String 声明的是不可变的对象，每次操作都会生成新的 String 对象，然后将指针指向新的 String 对象，而 StringBuffer、StringBuilder 可以在原有对象的基础上进行操作，所以在经常改变字符串内容的情况下最好不要使用 String。</p><p>StringBuffer 和 StringBuilder 最大的区别在于，StringBuffer 是线程安全的，而 StringBuilder 是非线程安全的，但 StringBuilder 的性能却高于 StringBuffer，所以在单线程环境下推荐使用 StringBuilder，多线程环境下推荐使用 StringBuffer。</p><h5 id="8-String-str-”i”与-String-str-new-String-“i”-一样吗？"><a href="#8-String-str-”i”与-String-str-new-String-“i”-一样吗？" class="headerlink" title="8. String str=”i”与 String str=new String(“i”)一样吗？"></a>8. String str=”i”与 String str=new String(“i”)一样吗？</h5><p>不一样，因为内存的分配方式不一样。String str=”i”的方式，Java 虚拟机会将其分配到常量池中；而 String str=new String(“i”) 则会被分到堆内存中。</p><h5 id="9-如何将字符串反转？"><a href="#9-如何将字符串反转？" class="headerlink" title="9. 如何将字符串反转？"></a>9. 如何将字符串反转？</h5><p>使用 StringBuilder 或者 stringBuffer 的 reverse() 方法。</p><p>示例代码：</p><pre><code>// StringBuffer reverseStringBuffer stringBuffer = new StringBuffer();stringBuffer. append(&quot;abcdefg&quot;);System. out. println(stringBuffer. reverse()); // gfedcba// StringBuilder reverseStringBuilder stringBuilder = new StringBuilder();stringBuilder. append(&quot;abcdefg&quot;);System. out. println(stringBuilder. reverse()); // gfedcba</code></pre><h5 id="10-String-类的常用方法都有那些？"><a href="#10-String-类的常用方法都有那些？" class="headerlink" title="10. String 类的常用方法都有那些？"></a>10. String 类的常用方法都有那些？</h5><pre><code>indexOf()：返回指定字符的索引。charAt()：返回指定索引处的字符。replace()：字符串替换。trim()：去除字符串两端空白。split()：分割字符串，返回一个分割后的字符串数组。getBytes()：返回字符串的 byte 类型数组。length()：返回字符串长度。toLowerCase()：将字符串转成小写字母。toUpperCase()：将字符串转成大写字符。substring()：截取字符串。equals()：字符串比较。</code></pre><h5 id="11-抽象类必须要有抽象方法吗？"><a href="#11-抽象类必须要有抽象方法吗？" class="headerlink" title="11. 抽象类必须要有抽象方法吗？"></a>11. 抽象类必须要有抽象方法吗？</h5><p>不需要，抽象类不一定非要有抽象方法。</p><p>示例代码：</p><pre><code>abstract class Cat {    public static void sayHi() {        System. out. println(&quot;hi~&quot;);    }}</code></pre><p>上面代码，抽象类并没有抽象方法但完全可以正常运行。</p><h5 id="12-普通类和抽象类有哪些区别？"><a href="#12-普通类和抽象类有哪些区别？" class="headerlink" title="12. 普通类和抽象类有哪些区别？"></a>12. 普通类和抽象类有哪些区别？</h5><p>普通类不能包含抽象方法，抽象类可以包含抽象方法。<br>抽象类不能直接实例化，普通类可以直接实例化。</p><h5 id="13-抽象类能使用-final-修饰吗？"><a href="#13-抽象类能使用-final-修饰吗？" class="headerlink" title="13. 抽象类能使用 final 修饰吗？"></a>13. 抽象类能使用 final 修饰吗？</h5><p>不能，定义抽象类就是让其他类继承的，如果定义为 final 该类就不能被继承，这样彼此就会产生矛盾，所以 final 不能修饰抽象类，如下图所示，编辑器也会提示错误信息：</p><h5 id="14-接口和抽象类有什么区别？"><a href="#14-接口和抽象类有什么区别？" class="headerlink" title="14. 接口和抽象类有什么区别？"></a>14. 接口和抽象类有什么区别？</h5><p>实现：抽象类的子类使用 extends 来继承；接口必须使用 implements 来实现接口。<br>构造函数：抽象类可以有构造函数；接口不能有。<br>实现数量：类可以实现很多个接口；但是只能继承一个抽象类。<br>访问修饰符：接口中的方法默认使用 public 修饰；抽象类中的方法可以是任意访问修饰符。</p><h5 id="15-Java-中-IO-流分为几种？"><a href="#15-Java-中-IO-流分为几种？" class="headerlink" title="15. Java 中 IO 流分为几种？"></a>15. Java 中 IO 流分为几种？</h5><p>按功能来分：输入流（input）、输出流（output）。</p><p>按类型来分：字节流和字符流。</p><p>字节流和字符流的区别是：字节流按 8 位传输以字节为单位输入输出数据，字符流按 16 位传输以字符为单位输入输出数据。</p><h5 id="16-BIO、NIO、AIO-有什么区别？"><a href="#16-BIO、NIO、AIO-有什么区别？" class="headerlink" title="16. BIO、NIO、AIO 有什么区别？"></a>16. BIO、NIO、AIO 有什么区别？</h5><p>BIO：Block IO 同步阻塞式 IO，就是我们平常使用的传统 IO，它的特点是模式简单使用方便，并发处理能力低。<br>NIO：New IO 同步非阻塞 IO，是传统 IO 的升级，客户端和服务器端通过 Channel（通道）通讯，实现了多路复用。<br>AIO：Asynchronous IO 是 NIO 的升级，也叫 NIO2，实现了异步非堵塞 IO ，异步 IO 的操作基于事件和回调机制。</p><h5 id="17-Files的常用方法都有哪些？"><a href="#17-Files的常用方法都有哪些？" class="headerlink" title="17. Files的常用方法都有哪些？"></a>17. Files的常用方法都有哪些？</h5><pre><code>Files. exists()：检测文件路径是否存在。Files. createFile()：创建文件。Files. createDirectory()：创建文件夹。Files. delete()：删除一个文件或目录。Files. copy()：复制文件。Files. move()：移动文件。Files. size()：查看文件个数。Files. read()：读取文件。Files. write()：写入文件。</code></pre><h3 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h3><h5 id="18-Java-容器都有哪些？"><a href="#18-Java-容器都有哪些？" class="headerlink" title="18. Java 容器都有哪些？"></a>18. Java 容器都有哪些？</h5><p>Java 容器分为 Collection 和 Map 两大类，其下又有很多子类，如下所示：</p><pre><code>Collection    List        ArrayList        LinkedList        Vector        Stack    Set        HashSet        LinkedHashSet        TreeSetMap    HashMap        LinkedHashMap    TreeMap    ConcurrentHashMap    Hashtable</code></pre><h5 id="19-Collection-和-Collections-有什么区别？"><a href="#19-Collection-和-Collections-有什么区别？" class="headerlink" title="19. Collection 和 Collections 有什么区别？"></a>19. Collection 和 Collections 有什么区别？</h5><p>Collection 是一个集合接口，它提供了对集合对象进行基本操作的通用接口方法，所有集合都是它的子类，比如 List、Set 等。<br>Collections 是一个包装类，包含了很多静态方法，不能被实例化，就像一个工具类，比如提供的排序方法： Collections. sort(list)。</p><h5 id="20-List、Set、Map-之间的区别是什么？"><a href="#20-List、Set、Map-之间的区别是什么？" class="headerlink" title="20. List、Set、Map 之间的区别是什么？"></a>20. List、Set、Map 之间的区别是什么？</h5><p>List、Set、Map 的区别主要体现在两个方面：元素是否有序、是否允许元素重复。</p><p>三者之间的区别，如下表：<br><img src="/2019/04/16/Java面试基础题/01.png" title="区别"></p><h5 id="21-HashMap-和-Hashtable-有什么区别？"><a href="#21-HashMap-和-Hashtable-有什么区别？" class="headerlink" title="21. HashMap 和 Hashtable 有什么区别？"></a>21. HashMap 和 Hashtable 有什么区别？</h5><p>存储：HashMap 运行 key 和 value 为 null，而 Hashtable 不允许。<br>线程安全：Hashtable 是线程安全的，而 HashMap 是非线程安全的。<br>推荐使用：在 Hashtable 的类注释可以看到，Hashtable 是保留类不建议使用，推荐在单线程环境下使用 HashMap 替代，如果需要多线程使用则用 ConcurrentHashMap 替代。</p><h5 id="22-如何决定使用-HashMap-还是-TreeMap？"><a href="#22-如何决定使用-HashMap-还是-TreeMap？" class="headerlink" title="22. 如何决定使用 HashMap 还是 TreeMap？"></a>22. 如何决定使用 HashMap 还是 TreeMap？</h5><p>对于在 Map 中插入、删除、定位一个元素这类操作，HashMap 是最好的选择，因为相对而言 HashMap 的插入会更快，但如果你要对一个 key 集合进行有序的遍历，那 TreeMap 是更好的选择。</p><h5 id="23-说一下-HashMap-的实现原理？"><a href="#23-说一下-HashMap-的实现原理？" class="headerlink" title="23. 说一下 HashMap 的实现原理？"></a>23. 说一下 HashMap 的实现原理？</h5><p>HashMap 基于 Hash 算法实现的，我们通过 put(key,value)存储，get(key)来获取。当传入 key 时，HashMap 会根据 key. hashCode() 计算出 hash 值，根据 hash 值将 value 保存在 bucket 里。当计算出的 hash 值相同时，我们称之为 hash 冲突，HashMap 的做法是用链表和红黑树存储相同 hash 值的 value。当 hash 冲突的个数比较少时，使用链表否则使用红黑树。</p><h5 id="24-说一下-HashSet-的实现原理？"><a href="#24-说一下-HashSet-的实现原理？" class="headerlink" title="24. 说一下 HashSet 的实现原理？"></a>24. 说一下 HashSet 的实现原理？</h5><p>HashSet 是基于 HashMap 实现的，HashSet 底层使用 HashMap 来保存所有元素，因此 HashSet 的实现比较简单，相关 HashSet 的操作，基本上都是直接调用底层 HashMap 的相关方法来完成，HashSet 不允许重复的值。</p><h5 id="25-ArrayList-和-LinkedList-的区别是什么？"><a href="#25-ArrayList-和-LinkedList-的区别是什么？" class="headerlink" title="25. ArrayList 和 LinkedList 的区别是什么？"></a>25. ArrayList 和 LinkedList 的区别是什么？</h5><p>数据结构实现：ArrayList 是动态数组的数据结构实现，而 LinkedList 是双向链表的数据结构实现。<br>随机访问效率：ArrayList 比 LinkedList 在随机访问的时候效率要高，因为 LinkedList 是线性的数据存储方式，所以需要移动指针从前往后依次查找。<br>增加和删除效率：在非首尾的增加和删除操作，LinkedList 要比 ArrayList 效率要高，因为 ArrayList 增删操作要影响数组内的其他数据的下标。<br>综合来说，在需要频繁读取集合中的元素时，更推荐使用 ArrayList，而在插入和删除操作较多时，更推荐使用 LinkedList。</p><h5 id="26-如何实现数组和-List-之间的转换？"><a href="#26-如何实现数组和-List-之间的转换？" class="headerlink" title="26. 如何实现数组和 List 之间的转换？"></a>26. 如何实现数组和 List 之间的转换？</h5><p>数组转 List：使用 Arrays. asList(array) 进行转换。<br>List 转数组：使用 List 自带的 toArray() 方法。<br>代码示例：</p><pre><code>// list to arrayList&lt;String&gt; list = new ArrayList&lt;String&gt;();list. add(&quot;王磊&quot;);list. add(&quot;的博客&quot;);list. toArray();// array to listString[] array = new String[]{&quot;王磊&quot;,&quot;的博客&quot;};Arrays. asList(array);</code></pre><h5 id="27-ArrayList-和-Vector-的区别是什么？"><a href="#27-ArrayList-和-Vector-的区别是什么？" class="headerlink" title="27. ArrayList 和 Vector 的区别是什么？"></a>27. ArrayList 和 Vector 的区别是什么？</h5><p>线程安全：Vector 使用了 Synchronized 来实现线程同步，是线程安全的，而 ArrayList 是非线程安全的。<br>性能：ArrayList 在性能方面要优于 Vector。<br>扩容：ArrayList 和 Vector 都会根据实际的需要动态的调整容量，只不过在 Vector 扩容每次会增加 1 倍，而 ArrayList 只会增加 50%。</p><h5 id="28-Array-和-ArrayList-有何区别？"><a href="#28-Array-和-ArrayList-有何区别？" class="headerlink" title="28. Array 和 ArrayList 有何区别？"></a>28. Array 和 ArrayList 有何区别？</h5><p>Array 可以存储基本数据类型和对象，ArrayList 只能存储对象。<br>Array 是指定固定大小的，而 ArrayList 大小是自动扩展的。<br>Array 内置方法没有 ArrayList 多，比如 addAll、removeAll、iteration 等方法只有 ArrayList 有。</p><h5 id="29-在-Queue-中-poll-和-remove-有什么区别？"><a href="#29-在-Queue-中-poll-和-remove-有什么区别？" class="headerlink" title="29. 在 Queue 中 poll()和 remove()有什么区别？"></a>29. 在 Queue 中 poll()和 remove()有什么区别？</h5><p>相同点：都是返回第一个元素，并在队列中删除返回的对象。<br>不同点：如果没有元素 poll()会返回 null，而 remove()会直接抛出 NoSuchElementException 异常。<br>代码示例：</p><pre><code>Queue&lt;String&gt; queue = new LinkedList&lt;String&gt;();queue. offer(&quot;string&quot;); // addSystem. out. println(queue. poll());System. out. println(queue. remove());System. out. println(queue. size());</code></pre><h5 id="30-哪些集合类是线程安全的？"><a href="#30-哪些集合类是线程安全的？" class="headerlink" title="30. 哪些集合类是线程安全的？"></a>30. 哪些集合类是线程安全的？</h5><p>Vector、Hashtable、Stack 都是线程安全的，而像 HashMap 则是非线程安全的，不过在 JDK 1.5 之后随着 Java. util. concurrent 并发包的出现，它们也有了自己对应的线程安全类，比如 HashMap 对应的线程安全类就是 ConcurrentHashMap。</p><h5 id="31-迭代器-Iterator-是什么？"><a href="#31-迭代器-Iterator-是什么？" class="headerlink" title="31. 迭代器 Iterator 是什么？"></a>31. 迭代器 Iterator 是什么？</h5><p>Iterator 接口提供遍历任何 Collection 的接口。我们可以从一个 Collection 中使用迭代器方法来获取迭代器实例。迭代器取代了 Java 集合框架中的 Enumeration，迭代器允许调用者在迭代过程中移除元素。</p><h5 id="32-Iterator-怎么使用？有什么特点？"><a href="#32-Iterator-怎么使用？有什么特点？" class="headerlink" title="32. Iterator 怎么使用？有什么特点？"></a>32. Iterator 怎么使用？有什么特点？</h5><p>Iterator 使用代码如下：</p><pre><code>List&lt;String&gt; list = new ArrayList&lt;&gt;();Iterator&lt;String&gt; it = list. iterator();while(it. hasNext()){  String obj = it. next();  System. out. println(obj);}</code></pre><p>Iterator 的特点是更加安全，因为它可以确保，在当前遍历的集合元素被更改的时候，就会抛出 ConcurrentModificationException 异常。</p><h5 id="33-Iterator-和-ListIterator-有什么区别？"><a href="#33-Iterator-和-ListIterator-有什么区别？" class="headerlink" title="33. Iterator 和 ListIterator 有什么区别？"></a>33. Iterator 和 ListIterator 有什么区别？</h5><p>Iterator 可以遍历 Set 和 List 集合，而 ListIterator 只能遍历 List。<br>Iterator 只能单向遍历，而 ListIterator 可以双向遍历（向前/后遍历）。<br>ListIterator 从 Iterator 接口继承，然后添加了一些额外的功能，比如添加一个元素、替换一个元素、获取前面或后面元素的索引位置。</p><h5 id="34-怎么确保一个集合不能被修改？"><a href="#34-怎么确保一个集合不能被修改？" class="headerlink" title="34. 怎么确保一个集合不能被修改？"></a>34. 怎么确保一个集合不能被修改？</h5><p>可以使用 Collections. unmodifiableCollection(Collection c) 方法来创建一个只读集合，这样改变集合的任何操作都会抛出 Java. lang. UnsupportedOperationException 异常。</p><p>示例代码如下：</p><pre><code>List&lt;String&gt; list = new ArrayList&lt;&gt;();list. add(&quot;x&quot;);Collection&lt;String&gt; clist = Collections. unmodifiableCollection(list);clist. add(&quot;y&quot;); // 运行时此行报错System. out. println(list. size());</code></pre><h3 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h3><h5 id="35-并行和并发有什么区别？"><a href="#35-并行和并发有什么区别？" class="headerlink" title="35. 并行和并发有什么区别？"></a>35. 并行和并发有什么区别？</h5><p>并行：多个处理器或多核处理器同时处理多个任务。<br>并发：多个任务在同一个 CPU 核上，按细分的时间片轮流(交替)执行，从逻辑上来看那些任务是同时执行。<br>如下图：</p><img src="/2019/04/16/Java面试基础题/02.jpg" title="区别"><p>并发 = 两个队列和一台咖啡机。</p><p>并行 = 两个队列和两台咖啡机。</p><h5 id="36-线程和进程的区别？"><a href="#36-线程和进程的区别？" class="headerlink" title="36. 线程和进程的区别？"></a>36. 线程和进程的区别？</h5><p>一个程序下至少有一个进程，一个进程下至少有一个线程，一个进程下也可以有多个线程来增加程序的执行速度。</p><h5 id="37-守护线程是什么？"><a href="#37-守护线程是什么？" class="headerlink" title="37. 守护线程是什么？"></a>37. 守护线程是什么？</h5><p>守护线程是运行在后台的一种特殊进程。它独立于控制终端并且周期性地执行某种任务或等待处理某些发生的事件。在 Java 中垃圾回收线程就是特殊的守护线程。</p><h5 id="38-创建线程有哪几种方式？"><a href="#38-创建线程有哪几种方式？" class="headerlink" title="38. 创建线程有哪几种方式？"></a>38. 创建线程有哪几种方式？</h5><p>创建线程有三种方式：</p><p>继承 Thread 重新 run 方法；<br>实现 Runnable 接口；<br>实现 Callable 接口。</p><h5 id="39-说一下-runnable-和-callable-有什么区别？"><a href="#39-说一下-runnable-和-callable-有什么区别？" class="headerlink" title="39. 说一下 runnable 和 callable 有什么区别？"></a>39. 说一下 runnable 和 callable 有什么区别？</h5><p>runnable 没有返回值，callable 可以拿到有返回值，callable 可以看作是 runnable 的补充。</p><h5 id="40-线程有哪些状态？"><a href="#40-线程有哪些状态？" class="headerlink" title="40. 线程有哪些状态？"></a>40. 线程有哪些状态？</h5><p>线程的状态：</p><pre><code>NEW 尚未启动RUNNABLE 正在执行中BLOCKED 阻塞的（被同步锁或者IO锁阻塞）WAITING 永久等待状态TIMED_WAITING 等待指定的时间重新被唤醒的状态TERMINATED 执行完成</code></pre><h5 id="41-sleep-和-wait-有什么区别？"><a href="#41-sleep-和-wait-有什么区别？" class="headerlink" title="41. sleep() 和 wait() 有什么区别？"></a>41. sleep() 和 wait() 有什么区别？</h5><p>类的不同：sleep() 来自 Thread，wait() 来自 Object。<br>释放锁：sleep() 不释放锁；wait() 释放锁。<br>用法不同：sleep() 时间到会自动恢复；wait() 可以使用 notify()/notifyAll()直接唤醒。</p><h5 id="42-notify-和-notifyAll-有什么区别？"><a href="#42-notify-和-notifyAll-有什么区别？" class="headerlink" title="42. notify()和 notifyAll()有什么区别？"></a>42. notify()和 notifyAll()有什么区别？</h5><p>notifyAll()会唤醒所有的线程，notify()之后唤醒一个线程。notifyAll() 调用后，会将全部线程由等待池移到锁池，然后参与锁的竞争，竞争成功则继续执行，如果不成功则留在锁池等待锁被释放后再次参与竞争。而 notify()只会唤醒一个线程，具体唤醒哪一个线程由虚拟机控制。</p><h5 id="43-线程的-run-和-start-有什么区别？"><a href="#43-线程的-run-和-start-有什么区别？" class="headerlink" title="43. 线程的 run() 和 start() 有什么区别？"></a>43. 线程的 run() 和 start() 有什么区别？</h5><p>start() 方法用于启动线程，run() 方法用于执行线程的运行时代码。run() 可以重复调用，而 start() 只能调用一次。</p><h5 id="44-创建线程池有哪几种方式？"><a href="#44-创建线程池有哪几种方式？" class="headerlink" title="44. 创建线程池有哪几种方式？"></a>44. 创建线程池有哪几种方式？</h5><p>线程池创建有七种方式，最核心的是最后一种：</p><pre><code>newSingleThreadExecutor()：它的特点在于工作线程数目被限制为     1，操作一个无界的工作队列，所以它保证了所有任务的都是被顺序执行，最多会有一个任务处于活动状态    ，并且不允许使用者改动线程池实例，因此可以避免其改变线程数目；newCachedThreadPool()：它是一种用来处理大量短时间工作任务的线程池，具有几个鲜明特点    ：它会试图缓存线程并重用，当无缓存线程可用时，就会创建新的工作线程；    如果线程闲置的时间超过 60 秒，则被终止并移出缓存；    长时间闲置时，这种线程池，不会消耗什么资源。其内部使用 SynchronousQueue 作为工作队列；newFixedThreadPool(int nThreads)：重用指定数目（nThreads）的线程，其背后使用的是无界的工作队列    ，任何时候最多有 nThreads 个工作线程是活动的。    这意味着，如果任务数量超过了活动队列数目，将在工作队列中等待空闲线程出现；    如果有工作线程退出，将会有新的工作线程被创建，以补足指定的数目 nThreads；newSingleThreadScheduledExecutor()：创建单线程池，返回 ScheduledExecutorService，    可以进行定时或周期性的工作调度；newScheduledThreadPool(int corePoolSize)：和newSingleThreadScheduledExecutor()类似    ，创建的是个 ScheduledExecutorService，可以进行定时或周期性的工作调度，    区别在于单一工作线程还是多个工作线程；newWorkStealingPool(int parallelism)：这是一个经常被人忽略的线程池，Java 8 才加入这个创建方法，    其内部会构建ForkJoinPool，利用Work-Stealing算法，并行地处理任务，不保证处理顺序；ThreadPoolExecutor()：是最原始的线程池创建，上面1-3创建方式都是对ThreadPoolExecutor的封装。</code></pre><h5 id="45-线程池都有哪些状态？"><a href="#45-线程池都有哪些状态？" class="headerlink" title="45. 线程池都有哪些状态？"></a>45. 线程池都有哪些状态？</h5><pre><code>RUNNING：这是最正常的状态，接受新的任务，处理等待队列中的任务。SHUTDOWN：不接受新的任务提交，但是会继续处理等待队列中的任务。STOP：不接受新的任务提交，不再处理等待队列中的任务，中断正在执行任务的线程。TIDYING：所有的任务都销毁了，workCount 为 0，线程池的状态在转换为 TIDYING 状态时    ，会执行钩子方法 terminated()。TERMINATED：terminated()方法结束后，线程池的状态就会变成这个。</code></pre><h5 id="46-线程池中-submit-和-execute-方法有什么区别？"><a href="#46-线程池中-submit-和-execute-方法有什么区别？" class="headerlink" title="46. 线程池中 submit() 和 execute() 方法有什么区别？"></a>46. 线程池中 submit() 和 execute() 方法有什么区别？</h5><pre><code>execute()：只能执行 Runnable 类型的任务。submit()：可以执行 Runnable 和 Callable 类型的任务。Callable 类型的任务可以获取执行的返回值，而 Runnable 执行无返回值。</code></pre><h5 id="47-在-Java-程序中怎么保证多线程的运行安全？"><a href="#47-在-Java-程序中怎么保证多线程的运行安全？" class="headerlink" title="47. 在 Java 程序中怎么保证多线程的运行安全？"></a>47. 在 Java 程序中怎么保证多线程的运行安全？</h5><p>方法一：使用安全类，比如 Java. util. concurrent 下的类。<br>方法二：使用自动锁 synchronized。<br>方法三：使用手动锁 Lock。<br>手动锁 Java 示例代码如下：</p><pre><code>Lock lock = new ReentrantLock();lock. lock();try {    System. out. println(&quot;获得锁&quot;);} catch (Exception e) {    // TODO: handle exception} finally {    System. out. println(&quot;释放锁&quot;);    lock. unlock();}</code></pre><h5 id="48-多线程中-synchronized-锁升级的原理是什么？"><a href="#48-多线程中-synchronized-锁升级的原理是什么？" class="headerlink" title="48. 多线程中 synchronized 锁升级的原理是什么？"></a>48. 多线程中 synchronized 锁升级的原理是什么？</h5><p>synchronized 锁升级原理：在锁对象的对象头里面有一个 threadid 字段，在第一次访问的时候 threadid 为空，jvm 让其持有偏向锁，并将 threadid 设置为其线程 id，再次进入的时候会先判断 threadid 是否与其线程 id 一致，如果一致则可以直接使用此对象，如果不一致，则升级偏向锁为轻量级锁，通过自旋循环一定次数来获取锁，执行一定次数之后，如果还没有正常获取到要使用的对象，此时就会把锁从轻量级升级为重量级锁，此过程就构成了 synchronized 锁的升级。</p><p>锁的升级的目的：锁升级是为了减低了锁带来的性能消耗。在 Java 6 之后优化 synchronized 的实现方式，使用了偏向锁升级为轻量级锁再升级到重量级锁的方式，从而减低了锁带来的性能消耗。</p><h5 id="49-什么是死锁？"><a href="#49-什么是死锁？" class="headerlink" title="49. 什么是死锁？"></a>49. 什么是死锁？</h5><p>当线程 A 持有独占锁a，并尝试去获取独占锁 b 的同时，线程 B 持有独占锁 b，并尝试获取独占锁 a 的情况下，就会发生 AB 两个线程由于互相持有对方需要的锁，而发生的阻塞现象，我们称为死锁。</p><h5 id="50-怎么防止死锁？"><a href="#50-怎么防止死锁？" class="headerlink" title="50. 怎么防止死锁？"></a>50. 怎么防止死锁？</h5><p>尽量使用 tryLock(long timeout, TimeUnit unit)的方法(ReentrantLock、ReentrantReadWriteLock)，设置超时时间，超时可以退出防止死锁。<br>尽量使用 Java. util. concurrent 并发类代替自己手写锁。<br>尽量降低锁的使用粒度，尽量不要几个功能用同一把锁。<br>尽量减少同步的代码块。</p><h5 id="51-ThreadLocal-是什么？有哪些使用场景？"><a href="#51-ThreadLocal-是什么？有哪些使用场景？" class="headerlink" title="51. ThreadLocal 是什么？有哪些使用场景？"></a>51. ThreadLocal 是什么？有哪些使用场景？</h5><p>ThreadLocal 为每个使用该变量的线程提供独立的变量副本，所以每一个线程都可以独立地改变自己的副本，而不会影响其它线程所对应的副本。</p><p>ThreadLocal 的经典使用场景是数据库连接和 session 管理等。</p><h5 id="52-说一下-synchronized-底层实现原理？"><a href="#52-说一下-synchronized-底层实现原理？" class="headerlink" title="52. 说一下 synchronized 底层实现原理？"></a>52. 说一下 synchronized 底层实现原理？</h5><p>synchronized 是由一对 monitorenter/monitorexit 指令实现的，monitor 对象是同步的基本实现单元。在 Java 6 之前，monitor 的实现完全是依靠操作系统内部的互斥锁，因为需要进行用户态到内核态的切换，所以同步操作是一个无差别的重量级操作，性能也很低。但在 Java 6 的时候，Java 虚拟机 对此进行了大刀阔斧地改进，提供了三种不同的 monitor 实现，也就是常说的三种不同的锁：偏向锁（Biased Locking）、轻量级锁和重量级锁，大大改进了其性能。</p><h5 id="53-synchronized-和-volatile-的区别是什么？"><a href="#53-synchronized-和-volatile-的区别是什么？" class="headerlink" title="53. synchronized 和 volatile 的区别是什么？"></a>53. synchronized 和 volatile 的区别是什么？</h5><p>volatile 是变量修饰符；synchronized 是修饰类、方法、代码段。<br>volatile 仅能实现变量的修改可见性，不能保证原子性；而 synchronized 则可以保证变量的修改可见性和原子性。<br>volatile 不会造成线程的阻塞；synchronized 可能会造成线程的阻塞。</p><h5 id="54-synchronized-和-Lock-有什么区别？"><a href="#54-synchronized-和-Lock-有什么区别？" class="headerlink" title="54. synchronized 和 Lock 有什么区别？"></a>54. synchronized 和 Lock 有什么区别？</h5><p>synchronized 可以给类、方法、代码块加锁；而 lock 只能给代码块加锁。<br>synchronized 不需要手动获取锁和释放锁，使用简单，发生异常会自动释放锁，不会造成死锁；而 lock 需要自己加锁和释放锁，如果使用不当没有 unLock()去释放锁就会造成死锁。<br>通过 Lock 可以知道有没有成功获取锁，而 synchronized 却无法办到。</p><h5 id="55-synchronized-和-ReentrantLock-区别是什么？"><a href="#55-synchronized-和-ReentrantLock-区别是什么？" class="headerlink" title="55. synchronized 和 ReentrantLock 区别是什么？"></a>55. synchronized 和 ReentrantLock 区别是什么？</h5><p>synchronized 早期的实现比较低效，对比 ReentrantLock，大多数场景性能都相差较大，但是在 Java 6 中对 synchronized 进行了非常多的改进。</p><p>主要区别如下：</p><p>ReentrantLock 使用起来比较灵活，但是必须有释放锁的配合动作；<br>ReentrantLock 必须手动获取与释放锁，而 synchronized 不需要手动释放和开启锁；<br>ReentrantLock 只适用于代码块锁，而 synchronized 可用于修饰方法、代码块等。<br>volatile 标记的变量不会被编译器优化；synchronized 标记的变量可以被编译器优化。</p><h5 id="56-说一下-atomic-的原理？"><a href="#56-说一下-atomic-的原理？" class="headerlink" title="56. 说一下 atomic 的原理？"></a>56. 说一下 atomic 的原理？</h5><p>atomic 主要利用 CAS (Compare And Wwap) 和 volatile 和 native 方法来保证原子操作，从而避免 synchronized 的高开销，执行效率大为提升。</p><h3 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h3><h5 id="57-什么是反射？"><a href="#57-什么是反射？" class="headerlink" title="57. 什么是反射？"></a>57. 什么是反射？</h5><p>反射是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性；这种动态获取的信息以及动态调用对象的方法的功能称为 Java 语言的反射机制。</p><h5 id="58-什么是-Java-序列化？什么情况下需要序列化？"><a href="#58-什么是-Java-序列化？什么情况下需要序列化？" class="headerlink" title="58. 什么是 Java 序列化？什么情况下需要序列化？"></a>58. 什么是 Java 序列化？什么情况下需要序列化？</h5><p>Java 序列化是为了保存各种对象在内存中的状态，并且可以把保存的对象状态再读出来。</p><p>以下情况需要使用 Java 序列化：</p><p>想把的内存中的对象状态保存到一个文件中或者数据库中时候；<br>想用套接字在网络上传送对象的时候；<br>想通过RMI（远程方法调用）传输对象的时候。</p><h5 id="59-动态代理是什么？有哪些应用？"><a href="#59-动态代理是什么？有哪些应用？" class="headerlink" title="59. 动态代理是什么？有哪些应用？"></a>59. 动态代理是什么？有哪些应用？</h5><p>动态代理是运行时动态生成代理类。</p><p>动态代理的应用有 spring aop、hibernate 数据查询、测试框架的后端 mock、rpc，Java注解对象获取等。</p><h5 id="60-怎么实现动态代理？"><a href="#60-怎么实现动态代理？" class="headerlink" title="60. 怎么实现动态代理？"></a>60. 怎么实现动态代理？</h5><p>JDK 原生动态代理和 cglib 动态代理。JDK 原生动态代理是基于接口实现的，而 cglib 是基于继承当前类的子类实现的。</p><h3 id="对象拷贝"><a href="#对象拷贝" class="headerlink" title="对象拷贝"></a>对象拷贝</h3><h5 id="61-为什么要使用克隆？"><a href="#61-为什么要使用克隆？" class="headerlink" title="61. 为什么要使用克隆？"></a>61. 为什么要使用克隆？</h5><p>克隆的对象可能包含一些已经修改过的属性，而 new 出来的对象的属性都还是初始化时候的值，所以当需要一个新的对象来保存当前对象的“状态”就靠克隆方法了。</p><h5 id="62-如何实现对象克隆？"><a href="#62-如何实现对象克隆？" class="headerlink" title="62. 如何实现对象克隆？"></a>62. 如何实现对象克隆？</h5><p>实现 Cloneable 接口并重写 Object 类中的 clone() 方法。<br>实现 Serializable 接口，通过对象的序列化和反序列化实现克隆，可以实现真正的深度克隆。</p><h5 id="63-深拷贝和浅拷贝区别是什么？"><a href="#63-深拷贝和浅拷贝区别是什么？" class="headerlink" title="63. 深拷贝和浅拷贝区别是什么？"></a>63. 深拷贝和浅拷贝区别是什么？</h5><p>浅克隆：当对象被复制时只复制它本身和其中包含的值类型的成员变量，而引用类型的成员对象并没有复制。<br>深克隆：除了对象本身被复制外，对象所包含的所有成员变量也将复制。</p><h3 id="Java-Web"><a href="#Java-Web" class="headerlink" title="Java Web"></a>Java Web</h3><h5 id="64-JSP-和-servlet-有什么区别？"><a href="#64-JSP-和-servlet-有什么区别？" class="headerlink" title="64. JSP 和 servlet 有什么区别？"></a>64. JSP 和 servlet 有什么区别？</h5><p>JSP 是 servlet 技术的扩展，本质上就是 servlet 的简易方式。servlet 和 JSP 最主要的不同点在于，servlet 的应用逻辑是在 Java 文件中，并且完全从表示层中的 html 里分离开来，而 JSP 的情况是 Java 和 html 可以组合成一个扩展名为 JSP 的文件。JSP 侧重于视图，servlet 主要用于控制逻辑。</p><h5 id="65-JSP-有哪些内置对象？作用分别是什么？"><a href="#65-JSP-有哪些内置对象？作用分别是什么？" class="headerlink" title="65. JSP 有哪些内置对象？作用分别是什么？"></a>65. JSP 有哪些内置对象？作用分别是什么？</h5><p>JSP 有 9 大内置对象：</p><pre><code>request：封装客户端的请求，其中包含来自 get 或 post 请求的参数；response：封装服务器对客户端的响应；pageContext：通过该对象可以获取其他对象；session：封装用户会话的对象；application：封装服务器运行环境的对象；out：输出服务器响应的输出流对象；config：Web 应用的配置对象；page：JSP 页面本身（相当于 Java 程序中的 this）；exception：封装页面抛出异常的对象。</code></pre><h5 id="66-说一下-JSP-的-4-种作用域？"><a href="#66-说一下-JSP-的-4-种作用域？" class="headerlink" title="66. 说一下 JSP 的 4 种作用域？"></a>66. 说一下 JSP 的 4 种作用域？</h5><p>page：代表与一个页面相关的对象和属性。<br>request：代表与客户端发出的一个请求相关的对象和属性。一个请求可能跨越多个页面，涉及多个 Web 组件；需要在页面显示的临时数据可以置于此作用域。<br>session：代表与某个用户与服务器建立的一次会话相关的对象和属性。跟某个用户相关的数据应该放在用户自己的 session 中。<br>application：代表与整个 Web 应用程序相关的对象和属性，它实质上是跨越整个 Web 应用程序，包括多个页面、请求和会话的一个全局作用域。</p><h5 id="67-session-和-cookie-有什么区别？"><a href="#67-session-和-cookie-有什么区别？" class="headerlink" title="67. session 和 cookie 有什么区别？"></a>67. session 和 cookie 有什么区别？</h5><p>存储位置不同：session 存储在服务器端；cookie 存储在浏览器端。<br>安全性不同：cookie 安全性一般，在浏览器存储，可以被伪造和修改。<br>容量和个数限制：cookie 有容量限制，每个站点下的 cookie 也有个数限制。<br>存储的多样性：session 可以存储在 Redis 中、数据库中、应用程序中；而 cookie 只能存储在浏览器中。</p><h5 id="68-说一下-session-的工作原理？"><a href="#68-说一下-session-的工作原理？" class="headerlink" title="68. 说一下 session 的工作原理？"></a>68. 说一下 session 的工作原理？</h5><p>session 的工作原理是客户端登录完成之后，服务器会创建对应的 session，session 创建完之后，会把 session 的 id 发送给客户端，客户端再存储到浏览器中。这样客户端每次访问服务器时，都会带着 sessionid，服务器拿到 sessionid 之后，在内存找到与之对应的 session 这样就可以正常工作了。</p><h5 id="69-如果客户端禁止-cookie-能实现-session-还能用吗？"><a href="#69-如果客户端禁止-cookie-能实现-session-还能用吗？" class="headerlink" title="69. 如果客户端禁止 cookie 能实现 session 还能用吗？"></a>69. 如果客户端禁止 cookie 能实现 session 还能用吗？</h5><p>可以用，session 只是依赖 cookie 存储 sessionid，如果 cookie 被禁用了，可以使用 url 中添加 sessionid 的方式保证 session 能正常使用。</p><h5 id="70-spring-mvc-和-struts-的区别是什么？"><a href="#70-spring-mvc-和-struts-的区别是什么？" class="headerlink" title="70. spring mvc 和 struts 的区别是什么？"></a>70. spring mvc 和 struts 的区别是什么？</h5><p>拦截级别：struts2 是类级别的拦截；spring mvc 是方法级别的拦截。<br>数据独立性：spring mvc 的方法之间基本上独立的，独享 request 和 response 数据，请求数据通过参数获取，处理结果通过 ModelMap 交回给框架，方法之间不共享变量；而 struts2 虽然方法之间也是独立的，但其所有 action 变量是共享的，这不会影响程序运行，却给我们编码和读程序时带来了一定的麻烦。<br>拦截机制：struts2 有以自己的 interceptor 机制，spring mvc 用的是独立的 aop 方式，这样导致struts2 的配置文件量比 spring mvc 大。<br>对 ajax 的支持：spring mvc 集成了ajax，所有 ajax 使用很方便，只需要一个注解 @ResponseBody 就可以实现了；而 struts2 一般需要安装插件或者自己写代码才行。</p><h5 id="71-如何避免-SQL-注入？"><a href="#71-如何避免-SQL-注入？" class="headerlink" title="71. 如何避免 SQL 注入？"></a>71. 如何避免 SQL 注入？</h5><p>使用预处理 PreparedStatement。<br>使用正则表达式过滤掉字符中的特殊字符。</p><h5 id="72-什么是-XSS-攻击，如何避免？"><a href="#72-什么是-XSS-攻击，如何避免？" class="headerlink" title="72. 什么是 XSS 攻击，如何避免？"></a>72. 什么是 XSS 攻击，如何避免？</h5><p>XSS 攻击：即跨站脚本攻击，它是 Web 程序中常见的漏洞。原理是攻击者往 Web 页面里插入恶意的脚本代码（css 代码、Javascript 代码等），当用户浏览该页面时，嵌入其中的脚本代码会被执行，从而达到恶意攻击用户的目的，如盗取用户 cookie、破坏页面结构、重定向到其他网站等。</p><p>预防 XSS 的核心是必须对输入的数据做过滤处理。</p><h5 id="73-什么是-CSRF-攻击，如何避免？"><a href="#73-什么是-CSRF-攻击，如何避免？" class="headerlink" title="73. 什么是 CSRF 攻击，如何避免？"></a>73. 什么是 CSRF 攻击，如何避免？</h5><p>CSRF：Cross-Site Request Forgery（中文：跨站请求伪造），可以理解为攻击者盗用了你的身份，以你的名义发送恶意请求，比如：以你名义发送邮件、发消息、购买商品，虚拟货币转账等。</p><p>防御手段：</p><p>验证请求来源地址；<br>关键操作添加验证码；<br>在请求地址添加 token 并验证。</p><h3 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h3><h5 id="74-throw-和-throws-的区别？"><a href="#74-throw-和-throws-的区别？" class="headerlink" title="74. throw 和 throws 的区别？"></a>74. throw 和 throws 的区别？</h5><p>throw：是真实抛出一个异常。<br>throws：是声明可能会抛出一个异常。</p><h5 id="75-final、finally、finalize-有什么区别？"><a href="#75-final、finally、finalize-有什么区别？" class="headerlink" title="75. final、finally、finalize 有什么区别？"></a>75. final、finally、finalize 有什么区别？</h5><p>final：是修饰符，如果修饰类，此类不能被继承；如果修饰方法和变量，则表示此方法和此变量不能在被改变，只能使用。<br>finally：是 try{} catch{} finally{} 最后一部分，表示不论发生任何情况都会执行，finally 部分可以省略，但如果 finally 部分存在，则一定会执行 finally 里面的代码。<br>finalize： 是 Object 类的一个方法，在垃圾收集器执行的时候会调用被回收对象的此方法。</p><h5 id="76-try-catch-finally-中哪个部分可以省略？"><a href="#76-try-catch-finally-中哪个部分可以省略？" class="headerlink" title="76. try-catch-finally 中哪个部分可以省略？"></a>76. try-catch-finally 中哪个部分可以省略？</h5><p>try-catch-finally 其中 catch 和 finally 都可以被省略，但是不能同时省略，也就是说有 try 的时候，必须后面跟一个 catch 或者 finally。</p><h5 id="77-try-catch-finally-中，如果-catch-中-return-了，finally-还会执行吗？"><a href="#77-try-catch-finally-中，如果-catch-中-return-了，finally-还会执行吗？" class="headerlink" title="77. try-catch-finally 中，如果 catch 中 return 了，finally 还会执行吗？"></a>77. try-catch-finally 中，如果 catch 中 return 了，finally 还会执行吗？</h5><p>finally 一定会执行，即使是 catch 中 return 了，catch 中的 return 会等 finally 中的代码执行完之后，才会执行。</p><h5 id="78-常见的异常类有哪些？"><a href="#78-常见的异常类有哪些？" class="headerlink" title="78. 常见的异常类有哪些？"></a>78. 常见的异常类有哪些？</h5><pre><code>NullPointerException 空指针异常ClassNotFoundException 指定类不存在NumberFormatException 字符串转换为数字异常IndexOutOfBoundsException 数组下标越界异常ClassCastException 数据类型转换异常FileNotFoundException 文件未找到异常NoSuchMethodException 方法不存在异常IOException IO 异常SocketException Socket 异常</code></pre><h3 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h3><h5 id="79-http-响应码-301-和-302-代表的是什么？有什么区别？"><a href="#79-http-响应码-301-和-302-代表的是什么？有什么区别？" class="headerlink" title="79. http 响应码 301 和 302 代表的是什么？有什么区别？"></a>79. http 响应码 301 和 302 代表的是什么？有什么区别？</h5><p>301：永久重定向。</p><p>302：暂时重定向。</p><p>它们的区别是，301 对搜索引擎优化（SEO）更加有利；302 有被提示为网络拦截的风险。</p><h5 id="80-forward-和-redirect-的区别？"><a href="#80-forward-和-redirect-的区别？" class="headerlink" title="80. forward 和 redirect 的区别？"></a>80. forward 和 redirect 的区别？</h5><p>forward 是转发 和 redirect 是重定向：</p><p>地址栏 url 显示：foward url 不会发生改变，redirect url 会发生改变；<br>数据共享：forward 可以共享 request 里的数据，redirect 不能共享；<br>效率：forward 比 redirect 效率高。</p><h5 id="81-简述-tcp-和-udp的区别？"><a href="#81-简述-tcp-和-udp的区别？" class="headerlink" title="81. 简述 tcp 和 udp的区别？"></a>81. 简述 tcp 和 udp的区别？</h5><p>tcp 和 udp 是 OSI 模型中的运输层中的协议。tcp 提供可靠的通信传输，而 udp 则常被用于让广播和细节控制交给应用的通信传输。</p><p>两者的区别大致如下：</p><p>tcp 面向连接，udp 面向非连接即发送数据前不需要建立链接；<br>tcp 提供可靠的服务（数据传输），udp 无法保证；<br>tcp 面向字节流，udp 面向报文；<br>tcp 数据传输慢，udp 数据传输快；</p><h5 id="82-tcp-为什么要三次握手，两次不行吗？为什么？"><a href="#82-tcp-为什么要三次握手，两次不行吗？为什么？" class="headerlink" title="82. tcp 为什么要三次握手，两次不行吗？为什么？"></a>82. tcp 为什么要三次握手，两次不行吗？为什么？</h5><p>如果采用两次握手，那么只要服务器发出确认数据包就会建立连接，但由于客户端此时并未响应服务器端的请求，那此时服务器端就会一直在等待客户端，这样服务器端就白白浪费了一定的资源。若采用三次握手，服务器端没有收到来自客户端的再此确认，则就会知道客户端并没有要求建立请求，就不会浪费服务器的资源。</p><h5 id="83-说一下-tcp-粘包是怎么产生的？"><a href="#83-说一下-tcp-粘包是怎么产生的？" class="headerlink" title="83. 说一下 tcp 粘包是怎么产生的？"></a>83. 说一下 tcp 粘包是怎么产生的？</h5><p>tcp 粘包可能发生在发送端或者接收端，分别来看两端各种产生粘包的原因：</p><p>发送端粘包：发送端需要等缓冲区满才发送出去，造成粘包；<br>接收方粘包：接收方不及时接收缓冲区的包，造成多个包接收。</p><h5 id="84-OSI-的七层模型都有哪些？"><a href="#84-OSI-的七层模型都有哪些？" class="headerlink" title="84. OSI 的七层模型都有哪些？"></a>84. OSI 的七层模型都有哪些？</h5><pre><code>物理层：利用传输介质为数据链路层提供物理连接，实现比特流的透明传输。数据链路层：负责建立和管理节点间的链路。网络层：通过路由选择算法，为报文或分组通过通信子网选择最适当的路径。传输层：向用户提供可靠的端到端的差错和流量控制，保证报文的正确传输。会话层：向两个实体的表示层提供建立和使用连接的方法。表示层：处理用户信息的表示问题，如编码、数据格式转换和加密解密等。应用层：直接向用户提供服务，完成用户希望在网络上完成的各种工作。</code></pre><h5 id="85-get-和-post-请求有哪些区别？"><a href="#85-get-和-post-请求有哪些区别？" class="headerlink" title="85. get 和 post 请求有哪些区别？"></a>85. get 和 post 请求有哪些区别？</h5><p>get 请求会被浏览器主动缓存，而 post 不会。<br>get 传递参数有大小限制，而 post 没有。<br>post 参数传输更安全，get 的参数会明文限制在 url 上，post 不会。</p><h5 id="86-如何实现跨域？"><a href="#86-如何实现跨域？" class="headerlink" title="86. 如何实现跨域？"></a>86. 如何实现跨域？</h5><p>实现跨域有以下几种方案：</p><p>服务器端运行跨域 设置 CORS 等于 *；<br>在单个接口使用注解 @CrossOrigin 运行跨域；<br>使用 jsonp 跨域；</p><h5 id="87-说一下-JSONP-实现原理？"><a href="#87-说一下-JSONP-实现原理？" class="headerlink" title="87. 说一下 JSONP 实现原理？"></a>87. 说一下 JSONP 实现原理？</h5><p>jsonp：JSON with Padding，它是利用script标签的 src 连接可以访问不同源的特性，加载远程返回的“JS 函数”来执行的。</p><h3 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h3><h5 id="88-说一下你熟悉的设计模式？"><a href="#88-说一下你熟悉的设计模式？" class="headerlink" title="88. 说一下你熟悉的设计模式？"></a>88. 说一下你熟悉的设计模式？</h5><p>单例模式：保证被创建一次，节省系统开销。<br>工厂模式（简单工厂、抽象工厂）：解耦代码。<br>观察者模式：定义了对象之间的一对多的依赖，这样一来，当一个对象改变时，它的所有的依赖者都会收到通知并自动更新。<br>外观模式：提供一个统一的接口，用来访问子系统中的一群接口，外观定义了一个高层的接口，让子系统更容易使用。<br>模版方法模式：定义了一个算法的骨架，而将一些步骤延迟到子类中，模版方法使得子类可以在不改变算法结构的情况下，重新定义算法的步骤。<br>状态模式：允许对象在内部状态改变时改变它的行为，对象看起来好像修改了它的类。</p><h5 id="89-简单工厂和抽象工厂有什么区别？"><a href="#89-简单工厂和抽象工厂有什么区别？" class="headerlink" title="89. 简单工厂和抽象工厂有什么区别？"></a>89. 简单工厂和抽象工厂有什么区别？</h5><pre><code>简单工厂：用来生产同一等级结构中的任意产品，对于增加新的产品，无能为力。工厂方法：用来生产同一等级结构中的固定产品，支持增加任意产品。抽象工厂：用来生产不同产品族的全部产品，对于增加新的产品，无能为力；支持增加产品族。</code></pre><h3 id="Spring-Spring-MVC"><a href="#Spring-Spring-MVC" class="headerlink" title="Spring/Spring MVC"></a>Spring/Spring MVC</h3><h5 id="90-为什么要使用-spring？"><a href="#90-为什么要使用-spring？" class="headerlink" title="90. 为什么要使用 spring？"></a>90. 为什么要使用 spring？</h5><p>spring 提供 ioc 技术，容器会帮你管理依赖的对象，从而不需要自己创建和管理依赖对象了，更轻松的实现了程序的解耦。<br>spring 提供了事务支持，使得事务操作变的更加方便。<br>spring 提供了面向切片编程，这样可以更方便的处理某一类的问题。<br>更方便的框架集成，spring 可以很方便的集成其他框架，比如 MyBatis、hibernate 等。</p><h5 id="91-解释一下什么是-aop？"><a href="#91-解释一下什么是-aop？" class="headerlink" title="91. 解释一下什么是 aop？"></a>91. 解释一下什么是 aop？</h5><p>aop 是面向切面编程，通过预编译方式和运行期动态代理实现程序功能的统一维护的一种技术。</p><p>简单来说就是统一处理某一“切面”（类）的问题的编程思想，比如统一处理日志、异常等。</p><h5 id="92-解释一下什么是-ioc？"><a href="#92-解释一下什么是-ioc？" class="headerlink" title="92. 解释一下什么是 ioc？"></a>92. 解释一下什么是 ioc？</h5><p>ioc：Inversionof Control（中文：控制反转）是 spring 的核心，对于 spring 框架来说，就是由 spring 来负责控制对象的生命周期和对象间的关系。</p><p>简单来说，控制指的是当前对象对内部成员的控制权；控制反转指的是，这种控制权不由当前对象管理了，由其他（类,第三方容器）来管理。</p><h5 id="93-spring-有哪些主要模块？"><a href="#93-spring-有哪些主要模块？" class="headerlink" title="93. spring 有哪些主要模块？"></a>93. spring 有哪些主要模块？</h5><pre><code>spring core：框架的最基础部分，提供 ioc 和依赖注入特性。spring context：构建于 core 封装包基础上的 context 封装包，提供了一种框架式的对象访问方法。spring dao：Data Access Object 提供了JDBC的抽象层。spring aop：提供了面向切面的编程实现，让你可以自定义拦截器、切点等。spring Web：提供了针对 Web 开发的集成特性，例如文件上传，利用 servlet listeners 进行 ioc 容器初始化和针对 Web 的 ApplicationContext。spring Web mvc：spring 中的 mvc 封装包提供了 Web 应用的 Model-View-Controller（MVC）的实现。</code></pre><h5 id="94-spring-常用的注入方式有哪些？"><a href="#94-spring-常用的注入方式有哪些？" class="headerlink" title="94. spring 常用的注入方式有哪些？"></a>94. spring 常用的注入方式有哪些？</h5><p>setter 属性注入<br>构造方法注入<br>注解方式注入</p><h5 id="95-spring-中的-bean-是线程安全的吗？"><a href="#95-spring-中的-bean-是线程安全的吗？" class="headerlink" title="95. spring 中的 bean 是线程安全的吗？"></a>95. spring 中的 bean 是线程安全的吗？</h5><p>spring 中的 bean 默认是单例模式，spring 框架并没有对单例 bean 进行多线程的封装处理。</p><p>实际上大部分时候 spring bean 无状态的（比如 dao 类），所有某种程度上来说 bean 也是安全的，但如果 bean 有状态的话（比如 view model 对象），那就要开发者自己去保证线程安全了，最简单的就是改变 bean 的作用域，把“singleton”变更为“prototype”，这样请求 bean 相当于 new Bean()了，所以就可以保证线程安全了。</p><p>有状态就是有数据存储功能。<br>无状态就是不会保存数据。</p><h5 id="96-spring-支持几种-bean-的作用域？"><a href="#96-spring-支持几种-bean-的作用域？" class="headerlink" title="96. spring 支持几种 bean 的作用域？"></a>96. spring 支持几种 bean 的作用域？</h5><p>spring 支持 5 种作用域，如下：</p><pre><code>singleton：spring ioc 容器中只存在一个 bean 实例，bean 以单例模式存在，是系统默认值；prototype：每次从容器调用 bean 时都会创建一个新的示例，既每次 getBean()相当于执行 new Bean()操作；Web 环境下的作用域：request：每次 http 请求都会创建一个 bean；session：同一个 http session 共享一个 bean 实例；global-session：用于 portlet 容器，因为每个 portlet 有单独的 session，globalsession 提供一个全局性的 http session。注意： 使用 prototype 作用域需要慎重的思考，因为频繁创建和销毁 bean 会带来很大的性能开销。</code></pre><h5 id="97-spring-自动装配-bean-有哪些方式？"><a href="#97-spring-自动装配-bean-有哪些方式？" class="headerlink" title="97. spring 自动装配 bean 有哪些方式？"></a>97. spring 自动装配 bean 有哪些方式？</h5><pre><code>no：默认值，表示没有自动装配，应使用显式 bean 引用进行装配。byName：它根据 bean 的名称注入对象依赖项。byType：它根据类型注入对象依赖项。构造函数：通过构造函数来注入依赖项，需要设置大量的参数。autodetect：容器首先通过构造函数使用 autowire 装配，如果不能，则通过 byType 自动装配。</code></pre><h5 id="98-spring-事务实现方式有哪些？"><a href="#98-spring-事务实现方式有哪些？" class="headerlink" title="98. spring 事务实现方式有哪些？"></a>98. spring 事务实现方式有哪些？</h5><p>声明式事务：声明式事务也有两种实现方式，基于 xml 配置文件的方式和注解方式（在类上添加 @Transaction 注解）。<br>编码方式：提供编码的形式管理和维护事务。</p><h5 id="99-说一下-spring-的事务隔离？"><a href="#99-说一下-spring-的事务隔离？" class="headerlink" title="99. 说一下 spring 的事务隔离？"></a>99. 说一下 spring 的事务隔离？</h5><p>spring 有五大隔离级别，默认值为 ISOLATION_DEFAULT（使用数据库的设置），其他四个隔离级别和数据库的隔离级别一致：</p><p>ISOLATION_DEFAULT：用底层数据库的设置隔离级别，数据库设置的是什么我就用什么；</p><p>ISOLATIONREADUNCOMMITTED：未提交读，最低隔离级别、事务未提交前，就可被其他事务读取（会出现幻读、脏读、不可重复读）；</p><p>ISOLATIONREADCOMMITTED：提交读，一个事务提交后才能被其他事务读取到（会造成幻读、不可重复读），SQL server 的默认级别；</p><p>ISOLATIONREPEATABLEREAD：可重复读，保证多次读取同一个数据时，其值都和事务开始时候的内容是一致，禁止读取到别的事务未提交的数据（会造成幻读），MySQL 的默认级别；</p><p>ISOLATION_SERIALIZABLE：序列化，代价最高最可靠的隔离级别，该隔离级别能防止脏读、不可重复读、幻读。</p><p>脏读 ：表示一个事务能够读取另一个事务中还未提交的数据。比如，某个事务尝试插入记录 A，此时该事务还未提交，然后另一个事务尝试读取到了记录 A。</p><p>不可重复读 ：是指在一个事务内，多次读同一数据。</p><p>幻读 ：指同一个事务内多次查询返回的结果集不一样。比如同一个事务 A 第一次查询时候有 n 条记录，但是第二次同等条件下查询却有 n+1 条记录，这就好像产生了幻觉。发生幻读的原因也是另外一个事务新增或者删除或者修改了第一个事务结果集里面的数据，同一个记录的数据内容被修改了，所有数据行的记录就变多或者变少了。</p><h5 id="100-说一下-spring-mvc-运行流程？"><a href="#100-说一下-spring-mvc-运行流程？" class="headerlink" title="100. 说一下 spring mvc 运行流程？"></a>100. 说一下 spring mvc 运行流程？</h5><pre><code>spring mvc 先将请求发送给 DispatcherServlet。DispatcherServlet 查询一个或多个 HandlerMapping，找到处理请求的 Controller。DispatcherServlet 再把请求提交到对应的 Controller。Controller 进行业务逻辑处理后，会返回一个ModelAndView。Dispathcher 查询一个或多个 ViewResolver 视图解析器，找到 ModelAndView 对象指定的视图对象。视图对象负责渲染返回给客户端。</code></pre><h5 id="101-spring-mvc-有哪些组件？"><a href="#101-spring-mvc-有哪些组件？" class="headerlink" title="101. spring mvc 有哪些组件？"></a>101. spring mvc 有哪些组件？</h5><pre><code>前置控制器 DispatcherServlet。映射控制器 HandlerMapping。处理器 Controller。模型和视图 ModelAndView。视图解析器 ViewResolver。</code></pre><h5 id="102-RequestMapping-的作用是什么？"><a href="#102-RequestMapping-的作用是什么？" class="headerlink" title="102. @RequestMapping 的作用是什么？"></a>102. @RequestMapping 的作用是什么？</h5><p>将 http 请求映射到相应的类/方法上。</p><h5 id="103-Autowired-的作用是什么？"><a href="#103-Autowired-的作用是什么？" class="headerlink" title="103. @Autowired 的作用是什么？"></a>103. @Autowired 的作用是什么？</h5><p>@Autowired 它可以对类成员变量、方法及构造函数进行标注，完成自动装配的工作，通过@Autowired 的使用来消除 set/get 方法。</p><h3 id="Spring-Boot-Spring-Cloud"><a href="#Spring-Boot-Spring-Cloud" class="headerlink" title="Spring Boot/Spring Cloud"></a>Spring Boot/Spring Cloud</h3><h5 id="104-什么是-spring-boot？"><a href="#104-什么是-spring-boot？" class="headerlink" title="104. 什么是 spring boot？"></a>104. 什么是 spring boot？</h5><p>spring boot 是为 spring 服务的，是用来简化新 spring 应用的初始搭建以及开发过程的。</p><h5 id="105-为什么要用-spring-boot？"><a href="#105-为什么要用-spring-boot？" class="headerlink" title="105. 为什么要用 spring boot？"></a>105. 为什么要用 spring boot？</h5><p>配置简单<br>独立运行<br>自动装配<br>无代码生成和 xml 配置<br>提供应用监控<br>易上手<br>提升开发效率</p><h5 id="106-spring-boot-核心配置文件是什么？"><a href="#106-spring-boot-核心配置文件是什么？" class="headerlink" title="106. spring boot 核心配置文件是什么？"></a>106. spring boot 核心配置文件是什么？</h5><p>spring boot 核心的两个配置文件：</p><p>bootstrap (. yml 或者 . properties)：boostrap 由父 ApplicationContext 加载的，比 applicaton 优先加载，且 boostrap 里面的属性不能被覆盖；<br>application (. yml 或者 . properties)：用于 spring boot 项目的自动化配置。</p><h5 id="107-spring-boot-配置文件有哪几种类型？它们有什么区别？"><a href="#107-spring-boot-配置文件有哪几种类型？它们有什么区别？" class="headerlink" title="107. spring boot 配置文件有哪几种类型？它们有什么区别？"></a>107. spring boot 配置文件有哪几种类型？它们有什么区别？</h5><p>配置文件有 . properties 格式和 . yml 格式，它们主要的区别是书法风格不同。</p><pre><code>. properties 配置如下：spring. RabbitMQ. port=5672. yml 配置如下：spring:    RabbitMQ:        port: 5672. yml 格式不支持 @PropertySource 注解导入。</code></pre><h5 id="108-spring-boot-有哪些方式可以实现热部署？"><a href="#108-spring-boot-有哪些方式可以实现热部署？" class="headerlink" title="108. spring boot 有哪些方式可以实现热部署？"></a>108. spring boot 有哪些方式可以实现热部署？</h5><p>使用 devtools 启动热部署，添加 devtools 库，在配置文件中把 spring. devtools. restart. enabled 设置为 true；<br>使用 Intellij Idea 编辑器，勾上自动编译或手动重新编译。</p><h5 id="109-jpa-和-hibernate-有什么区别？"><a href="#109-jpa-和-hibernate-有什么区别？" class="headerlink" title="109. jpa 和 hibernate 有什么区别？"></a>109. jpa 和 hibernate 有什么区别？</h5><p>jpa 全称 Java Persistence API，是 Java 持久化接口规范，hibernate 属于 jpa 的具体实现。</p><h5 id="110-什么是-spring-cloud？"><a href="#110-什么是-spring-cloud？" class="headerlink" title="110. 什么是 spring cloud？"></a>110. 什么是 spring cloud？</h5><p>spring cloud 是一系列框架的有序集合。它利用 spring boot 的开发便利性巧妙地简化了分布式系统基础设施的开发，如服务发现注册、配置中心、消息总线、负载均衡、断路器、数据监控等，都可以用 spring boot 的开发风格做到一键启动和部署。</p><h5 id="111-spring-cloud-断路器的作用是什么？"><a href="#111-spring-cloud-断路器的作用是什么？" class="headerlink" title="111. spring cloud 断路器的作用是什么？"></a>111. spring cloud 断路器的作用是什么？</h5><p>在分布式架构中，断路器模式的作用也是类似的，当某个服务单元发生故障（类似用电器发生短路）之后，通过断路器的故障监控（类似熔断保险丝），向调用方返回一个错误响应，而不是长时间的等待。这样就不会使得线程因调用故障服务被长时间占用不释放，避免了故障在分布式系统中的蔓延。</p><h5 id="112-spring-cloud-的核心组件有哪些？"><a href="#112-spring-cloud-的核心组件有哪些？" class="headerlink" title="112. spring cloud 的核心组件有哪些？"></a>112. spring cloud 的核心组件有哪些？</h5><pre><code>Eureka：服务注册于发现。Feign：基于动态代理机制，根据注解和选择的机器，拼接请求 url 地址，发起请求。Ribbon：实现负载均衡，从一个服务的多台机器中选择一台。Hystrix：提供线程池，不同的服务走不同的线程池，实现了不同服务调用的隔离，避免了服务雪崩的问题。Zuul：网关管理，由 Zuul 网关转发请求给对应的服务。</code></pre><h3 id="Hibernate"><a href="#Hibernate" class="headerlink" title="Hibernate"></a>Hibernate</h3><h5 id="113-为什么要使用-hibernate？"><a href="#113-为什么要使用-hibernate？" class="headerlink" title="113. 为什么要使用 hibernate？"></a>113. 为什么要使用 hibernate？</h5><p>hibernate 是对 jdbc 的封装，大大简化了数据访问层的繁琐的重复性代码。<br>hibernate 是一个优秀的 ORM 实现，很多程度上简化了 DAO 层的编码功能。<br>可以很方便的进行数据库的移植工作。<br>提供了缓存机制，是程序执行更改的高效。</p><h5 id="114-什么是-ORM-框架？"><a href="#114-什么是-ORM-框架？" class="headerlink" title="114. 什么是 ORM 框架？"></a>114. 什么是 ORM 框架？</h5><p>ORM（Object Relation Mapping）对象关系映射，是把数据库中的关系数据映射成为程序中的对象。</p><p>使用 ORM 的优点：提高了开发效率降低了开发成本、开发更简单更对象化、可移植更强。</p><h5 id="115-hibernate-中如何在控制台查看打印的-SQL-语句？"><a href="#115-hibernate-中如何在控制台查看打印的-SQL-语句？" class="headerlink" title="115. hibernate 中如何在控制台查看打印的 SQL 语句？"></a>115. hibernate 中如何在控制台查看打印的 SQL 语句？</h5><p>在 Config 里面把 hibernate. show_SQL 设置为 true 就可以。但不建议开启，开启之后会降低程序的运行效率。</p><h5 id="116-hibernate-有几种查询方式？"><a href="#116-hibernate-有几种查询方式？" class="headerlink" title="116. hibernate 有几种查询方式？"></a>116. hibernate 有几种查询方式？</h5><p>三种：hql、原生 SQL、条件查询 Criteria。</p><h5 id="117-hibernate-实体类可以被定义为-final-吗？"><a href="#117-hibernate-实体类可以被定义为-final-吗？" class="headerlink" title="117. hibernate 实体类可以被定义为 final 吗？"></a>117. hibernate 实体类可以被定义为 final 吗？</h5><p>实体类可以定义为 final 类，但这样的话就不能使用 hibernate 代理模式下的延迟关联提供性能了，所以不建议定义实体类为 final。</p><h5 id="118-在-hibernate-中使用-Integer-和-int-做映射有什么区别？"><a href="#118-在-hibernate-中使用-Integer-和-int-做映射有什么区别？" class="headerlink" title="118. 在 hibernate 中使用 Integer 和 int 做映射有什么区别？"></a>118. 在 hibernate 中使用 Integer 和 int 做映射有什么区别？</h5><p>Integer 类型为对象，它的值允许为 null，而 int 属于基础数据类型，值不能为 null。</p><h5 id="119-hibernate-是如何工作的？"><a href="#119-hibernate-是如何工作的？" class="headerlink" title="119. hibernate 是如何工作的？"></a>119. hibernate 是如何工作的？</h5><p>读取并解析配置文件。<br>读取并解析映射文件，创建 SessionFactory。<br>打开 Session。<br>创建事务。<br>进行持久化操作。<br>提交事务。<br>关闭 Session。<br>关闭 SessionFactory。</p><h5 id="120-get-和-load-的区别？"><a href="#120-get-和-load-的区别？" class="headerlink" title="120. get()和 load()的区别？"></a>120. get()和 load()的区别？</h5><p>数据查询时，没有 OID 指定的对象，get() 返回 null；load() 返回一个代理对象。<br>load()支持延迟加载；get() 不支持延迟加载。</p><h5 id="121-说一下-hibernate-的缓存机制？"><a href="#121-说一下-hibernate-的缓存机制？" class="headerlink" title="121. 说一下 hibernate 的缓存机制？"></a>121. 说一下 hibernate 的缓存机制？</h5><p>hibernate 常用的缓存有一级缓存和二级缓存：</p><p>一级缓存：也叫 Session 缓存，只在 Session 作用范围内有效，不需要用户干涉，由 hibernate 自身维护，可以通过：evict(object)清除 object 的缓存；clear()清除一级缓存中的所有缓存；flush()刷出缓存；</p><p>二级缓存：应用级别的缓存，在所有 Session 中都有效，支持配置第三方的缓存，如：EhCache。</p><h5 id="122-hibernate-对象有哪些状态？"><a href="#122-hibernate-对象有哪些状态？" class="headerlink" title="122. hibernate 对象有哪些状态？"></a>122. hibernate 对象有哪些状态？</h5><p>临时/瞬时状态：直接 new 出来的对象，该对象还没被持久化（没保存在数据库中），不受 Session 管理。<br>持久化状态：当调用 Session 的 save/saveOrupdate/get/load/list 等方法的时候，对象就是持久化状态。<br>游离状态：Session 关闭之后对象就是游离状态。</p><h5 id="123-在-hibernate-中-getCurrentSession-和-openSession-的区别是什么？"><a href="#123-在-hibernate-中-getCurrentSession-和-openSession-的区别是什么？" class="headerlink" title="123. 在 hibernate 中 getCurrentSession 和 openSession 的区别是什么？"></a>123. 在 hibernate 中 getCurrentSession 和 openSession 的区别是什么？</h5><p>getCurrentSession 会绑定当前线程，而 openSession 则不会。<br>getCurrentSession 事务是 Spring 控制的，并且不需要手动关闭，而 openSession 需要我们自己手动开启和提交事务。</p><h5 id="124-hibernate-实体类必须要有无参构造函数吗？为什么？"><a href="#124-hibernate-实体类必须要有无参构造函数吗？为什么？" class="headerlink" title="124. hibernate 实体类必须要有无参构造函数吗？为什么？"></a>124. hibernate 实体类必须要有无参构造函数吗？为什么？</h5><p>hibernate 中每个实体类必须提供一个无参构造函数，因为 hibernate 框架要使用 reflection api，通过调用 ClassnewInstance() 来创建实体类的实例，如果没有无参的构造函数就会抛出异常。</p><h3 id="MyBatis"><a href="#MyBatis" class="headerlink" title="MyBatis"></a>MyBatis</h3><h5 id="125-MyBatis-中-和-的区别是什么？"><a href="#125-MyBatis-中-和-的区别是什么？" class="headerlink" title="125. MyBatis 中 #{}和 ${}的区别是什么？"></a>125. MyBatis 中 #{}和 ${}的区别是什么？</h5><p>#{}是预编译处理，${}是字符替换。 在使用 #{}时，MyBatis 会将 SQL 中的 #{}替换成“?”，配合 PreparedStatement 的 set 方法赋值，这样可以有效的防止 SQL 注入，保证程序的运行安全。</p><h5 id="126-MyBatis-有几种分页方式？"><a href="#126-MyBatis-有几种分页方式？" class="headerlink" title="126. MyBatis 有几种分页方式？"></a>126. MyBatis 有几种分页方式？</h5><p>分页方式：逻辑分页和物理分页。</p><p>逻辑分页： 使用 MyBatis 自带的 RowBounds 进行分页，它是一次性查询很多数据，然后在数据中再进行检索。</p><p>物理分页： 自己手写 SQL 分页或使用分页插件 PageHelper，去数据库查询指定条数的分页数据的形式。</p><h5 id="127-RowBounds-是一次性查询全部结果吗？为什么？"><a href="#127-RowBounds-是一次性查询全部结果吗？为什么？" class="headerlink" title="127. RowBounds 是一次性查询全部结果吗？为什么？"></a>127. RowBounds 是一次性查询全部结果吗？为什么？</h5><p>RowBounds 表面是在“所有”数据中检索数据，其实并非是一次性查询出所有数据，因为 MyBatis 是对 jdbc 的封装，在 jdbc 驱动中有一个 Fetch Size 的配置，它规定了每次最多从数据库查询多少条数据，假如你要查询更多数据，它会在你执行 next()的时候，去查询更多的数据。就好比你去自动取款机取 10000 元，但取款机每次最多能取 2500 元，所以你要取 4 次才能把钱取完。只是对于 jdbc 来说，当你调用 next()的时候会自动帮你完成查询工作。这样做的好处可以有效的防止内存溢出。</p><p>Fetch Size 官方相关文档：<a href="http://t" target="_blank" rel="noopener">http://t</a>. cn/EfSE2g3</p><h5 id="128-MyBatis-逻辑分页和物理分页的区别是什么？"><a href="#128-MyBatis-逻辑分页和物理分页的区别是什么？" class="headerlink" title="128. MyBatis 逻辑分页和物理分页的区别是什么？"></a>128. MyBatis 逻辑分页和物理分页的区别是什么？</h5><p>逻辑分页是一次性查询很多数据，然后再在结果中检索分页的数据。这样做弊端是需要消耗大量的内存、有内存溢出的风险、对数据库压力较大。<br>物理分页是从数据库查询指定条数的数据，弥补了一次性全部查出的所有数据的种种缺点，比如需要大量的内存，对数据库查询压力较大等问题。</p><h5 id="129-MyBatis-是否支持延迟加载？延迟加载的原理是什么？"><a href="#129-MyBatis-是否支持延迟加载？延迟加载的原理是什么？" class="headerlink" title="129. MyBatis 是否支持延迟加载？延迟加载的原理是什么？"></a>129. MyBatis 是否支持延迟加载？延迟加载的原理是什么？</h5><p>MyBatis 支持延迟加载，设置 lazyLoadingEnabled=true 即可。</p><p>延迟加载的原理的是调用的时候触发加载，而不是在初始化的时候就加载信息。比如调用 a. getB(). getName()，这个时候发现 a. getB() 的值为 null，此时会单独触发事先保存好的关联 B 对象的 SQL，先查询出来 B，然后再调用 a. setB(b)，而这时候再调用 a. getB(). getName() 就有值了，这就是延迟加载的基本原理。</p><h5 id="130-说一下-MyBatis-的一级缓存和二级缓存？"><a href="#130-说一下-MyBatis-的一级缓存和二级缓存？" class="headerlink" title="130. 说一下 MyBatis 的一级缓存和二级缓存？"></a>130. 说一下 MyBatis 的一级缓存和二级缓存？</h5><p>一级缓存：基于 PerpetualCache 的 HashMap 本地缓存，它的声明周期是和 SQLSession 一致的，有多个 SQLSession 或者分布式的环境中数据库操作，可能会出现脏数据。当 Session flush 或 close 之后，该 Session 中的所有 Cache 就将清空，默认一级缓存是开启的。<br>二级缓存：也是基于 PerpetualCache 的 HashMap 本地缓存，不同在于其存储作用域为 Mapper 级别的，如果多个SQLSession之间需要共享缓存，则需要使用到二级缓存，并且二级缓存可自定义存储源，如 Ehcache。默认不打开二级缓存，要开启二级缓存，使用二级缓存属性类需要实现 Serializable 序列化接口(可用来保存对象的状态)。<br>开启二级缓存数据查询流程：二级缓存 -&gt; 一级缓存 -&gt; 数据库。</p><p>缓存更新机制：当某一个作用域(一级缓存 Session/二级缓存 Mapper)进行了C/U/D 操作后，默认该作用域下所有 select 中的缓存将被 clear。</p><h5 id="131-MyBatis-和-hibernate-的区别有哪些？"><a href="#131-MyBatis-和-hibernate-的区别有哪些？" class="headerlink" title="131. MyBatis 和 hibernate 的区别有哪些？"></a>131. MyBatis 和 hibernate 的区别有哪些？</h5><p>灵活性：MyBatis 更加灵活，自己可以写 SQL 语句，使用起来比较方便。<br>可移植性：MyBatis 有很多自己写的 SQL，因为每个数据库的 SQL 可以不相同，所以可移植性比较差。<br>学习和使用门槛：MyBatis 入门比较简单，使用门槛也更低。<br>二级缓存：hibernate 拥有更好的二级缓存，它的二级缓存可以自行更换为第三方的二级缓存。</p><ol start="132"><li>MyBatis 有哪些执行器（Executor）？</li></ol><h5 id="MyBatis-有三种基本的Executor执行器："><a href="#MyBatis-有三种基本的Executor执行器：" class="headerlink" title="MyBatis 有三种基本的Executor执行器："></a>MyBatis 有三种基本的Executor执行器：</h5><p>SimpleExecutor：每执行一次 update 或 select 就开启一个 Statement 对象，用完立刻关闭 Statement 对象；<br>ReuseExecutor：执行 update 或 select，以 SQL 作为 key 查找 Statement 对象，存在就使用，不存在就创建，用完后不关闭 Statement 对象，而是放置于 Map 内供下一次使用。简言之，就是重复使用 Statement 对象；<br>BatchExecutor：执行 update（没有 select，jdbc 批处理不支持 select），将所有 SQL 都添加到批处理中（addBatch()），等待统一执行（executeBatch()），它缓存了多个 Statement 对象，每个 Statement 对象都是 addBatch()完毕后，等待逐一执行 executeBatch()批处理，与 jdbc 批处理相同。</p><h5 id="133-MyBatis-分页插件的实现原理是什么？"><a href="#133-MyBatis-分页插件的实现原理是什么？" class="headerlink" title="133. MyBatis 分页插件的实现原理是什么？"></a>133. MyBatis 分页插件的实现原理是什么？</h5><p>分页插件的基本原理是使用 MyBatis 提供的插件接口，实现自定义插件，在插件的拦截方法内拦截待执行的 SQL，然后重写 SQL，根据 dialect 方言，添加对应的物理分页语句和物理分页参数。</p><h5 id="134-MyBatis-如何编写一个自定义插件？"><a href="#134-MyBatis-如何编写一个自定义插件？" class="headerlink" title="134. MyBatis 如何编写一个自定义插件？"></a>134. MyBatis 如何编写一个自定义插件？</h5><p>自定义插件实现原理</p><p>MyBatis 自定义插件针对 MyBatis 四大对象（Executor、StatementHandler、ParameterHandler、ResultSetHandler）进行拦截：</p><p>Executor：拦截内部执行器，它负责调用 StatementHandler 操作数据库，并把结果集通过 ResultSetHandler 进行自动映射，另外它还处理了二级缓存的操作；<br>StatementHandler：拦截 SQL 语法构建的处理，它是 MyBatis 直接和数据库执行 SQL 脚本的对象，另外它也实现了 MyBatis 的一级缓存；<br>ParameterHandler：拦截参数的处理；<br>ResultSetHandler：拦截结果集的处理。<br>自定义插件实现关键</p><p>MyBatis 插件要实现 Interceptor 接口，接口包含的方法，如下：</p><pre><code>public interface Interceptor {      Object intercept(Invocation invocation) throws Throwable;          Object plugin(Object target);       void setProperties(Properties properties);}</code></pre><p>setProperties 方法是在 MyBatis 进行配置插件的时候可以配置自定义相关属性，即：接口实现对象的参数配置；<br>plugin 方法是插件用于封装目标对象的，通过该方法我们可以返回目标对象本身，也可以返回一个它的代理，可以决定是否要进行拦截进而决定要返回一个什么样的目标对象，官方提供了示例：return Plugin. wrap(target, this)；<br>intercept 方法就是要进行拦截的时候要执行的方法。<br>自定义插件实现示例</p><p>官方插件实现：</p><pre><code>@Intercepts({@Signature(type = Executor. class, method = &quot;query&quot;,        args = {MappedStatement. class, Object. class, RowBounds. class, ResultHandler. class})})public class TestInterceptor implements Interceptor {   public Object intercept(Invocation invocation) throws Throwable {     Object target = invocation. getTarget(); //被代理对象     Method method = invocation. getMethod(); //代理方法     Object[] args = invocation. getArgs(); //方法参数     // do something . . . . . .  方法拦截前执行代码块     Object result = invocation. proceed();     // do something . . . . . . . 方法拦截后执行代码块     return result;   }   public Object plugin(Object target) {     return Plugin. wrap(target, this);   }}</code></pre><h3 id="RabbitMQ"><a href="#RabbitMQ" class="headerlink" title="RabbitMQ"></a>RabbitMQ</h3><h5 id="135-RabbitMQ-的使用场景有哪些？"><a href="#135-RabbitMQ-的使用场景有哪些？" class="headerlink" title="135. RabbitMQ 的使用场景有哪些？"></a>135. RabbitMQ 的使用场景有哪些？</h5><p>抢购活动，削峰填谷，防止系统崩塌。<br>延迟信息处理，比如 10 分钟之后给下单未付款的用户发送邮件提醒。<br>解耦系统，对于新增的功能可以单独写模块扩展，比如用户确认评价之后，新增了给用户返积分的功能，这个时候不用在业务代码里添加新增积分的功能，只需要把新增积分的接口订阅确认评价的消息队列即可，后面再添加任何功能只需要订阅对应的消息队列即可。</p><h5 id="136-RabbitMQ-有哪些重要的角色？"><a href="#136-RabbitMQ-有哪些重要的角色？" class="headerlink" title="136. RabbitMQ 有哪些重要的角色？"></a>136. RabbitMQ 有哪些重要的角色？</h5><p>RabbitMQ 中重要的角色有：生产者、消费者和代理：</p><p>生产者：消息的创建者，负责创建和推送数据到消息服务器；<br>消费者：消息的接收方，用于处理数据和确认消息；<br>代理：就是 RabbitMQ 本身，用于扮演“快递”的角色，本身不生产消息，只是扮演“快递”的角色。</p><h5 id="137-RabbitMQ-有哪些重要的组件？"><a href="#137-RabbitMQ-有哪些重要的组件？" class="headerlink" title="137. RabbitMQ 有哪些重要的组件？"></a>137. RabbitMQ 有哪些重要的组件？</h5><p>ConnectionFactory（连接管理器）：应用程序与Rabbit之间建立连接的管理器，程序代码中使用。<br>Channel（信道）：消息推送使用的通道。<br>Exchange（交换器）：用于接受、分配消息。<br>Queue（队列）：用于存储生产者的消息。<br>RoutingKey（路由键）：用于把生成者的数据分配到交换器上。<br>BindingKey（绑定键）：用于把交换器的消息绑定到队列上。</p><h5 id="138-RabbitMQ-中-vhost-的作用是什么？"><a href="#138-RabbitMQ-中-vhost-的作用是什么？" class="headerlink" title="138. RabbitMQ 中 vhost 的作用是什么？"></a>138. RabbitMQ 中 vhost 的作用是什么？</h5><p>vhost：每个 RabbitMQ 都能创建很多 vhost，我们称之为虚拟主机，每个虚拟主机其实都是 mini 版的RabbitMQ，它拥有自己的队列，交换器和绑定，拥有自己的权限机制。</p><h5 id="139-RabbitMQ-的消息是怎么发送的？"><a href="#139-RabbitMQ-的消息是怎么发送的？" class="headerlink" title="139. RabbitMQ 的消息是怎么发送的？"></a>139. RabbitMQ 的消息是怎么发送的？</h5><p>首先客户端必须连接到 RabbitMQ 服务器才能发布和消费消息，客户端和 rabbit server 之间会创建一个 tcp 连接，一旦 tcp 打开并通过了认证（认证就是你发送给 rabbit 服务器的用户名和密码），你的客户端和 RabbitMQ 就创建了一条 amqp 信道（channel），信道是创建在“真实” tcp 上的虚拟连接，amqp 命令都是通过信道发送出去的，每个信道都会有一个唯一的 id，不论是发布消息，订阅队列都是通过这个信道完成的。</p><h5 id="140-RabbitMQ-怎么保证消息的稳定性？"><a href="#140-RabbitMQ-怎么保证消息的稳定性？" class="headerlink" title="140. RabbitMQ 怎么保证消息的稳定性？"></a>140. RabbitMQ 怎么保证消息的稳定性？</h5><p>提供了事务的功能。<br>通过将 channel 设置为 confirm（确认）模式。</p><h5 id="141-RabbitMQ-怎么避免消息丢失？"><a href="#141-RabbitMQ-怎么避免消息丢失？" class="headerlink" title="141. RabbitMQ 怎么避免消息丢失？"></a>141. RabbitMQ 怎么避免消息丢失？</h5><p>把消息持久化磁盘，保证服务器重启消息不丢失。<br>每个集群中至少有一个物理磁盘，保证消息落入磁盘。</p><h5 id="142-要保证消息持久化成功的条件有哪些？"><a href="#142-要保证消息持久化成功的条件有哪些？" class="headerlink" title="142. 要保证消息持久化成功的条件有哪些？"></a>142. 要保证消息持久化成功的条件有哪些？</h5><p>声明队列必须设置持久化 durable 设置为 true.<br>消息推送投递模式必须设置持久化，deliveryMode 设置为 2（持久）。<br>消息已经到达持久化交换器。<br>消息已经到达持久化队列。<br>以上四个条件都满足才能保证消息持久化成功。</p><h5 id="143-RabbitMQ-持久化有什么缺点？"><a href="#143-RabbitMQ-持久化有什么缺点？" class="headerlink" title="143. RabbitMQ 持久化有什么缺点？"></a>143. RabbitMQ 持久化有什么缺点？</h5><p>持久化的缺地就是降低了服务器的吞吐量，因为使用的是磁盘而非内存存储，从而降低了吞吐量。可尽量使用 ssd 硬盘来缓解吞吐量的问题。</p><h5 id="144-RabbitMQ-有几种广播类型？"><a href="#144-RabbitMQ-有几种广播类型？" class="headerlink" title="144. RabbitMQ 有几种广播类型？"></a>144. RabbitMQ 有几种广播类型？</h5><p>direct（默认方式）：最基础最简单的模式，发送方把消息发送给订阅方，如果有多个订阅者，默认采取轮询的方式进行消息发送。<br>headers：与 direct 类似，只是性能很差，此类型几乎用不到。<br>fanout：分发模式，把消费分发给所有订阅者。<br>topic：匹配订阅模式，使用正则匹配到消息队列，能匹配到的都能接收到。</p><h5 id="145-RabbitMQ-怎么实现延迟消息队列？"><a href="#145-RabbitMQ-怎么实现延迟消息队列？" class="headerlink" title="145. RabbitMQ 怎么实现延迟消息队列？"></a>145. RabbitMQ 怎么实现延迟消息队列？</h5><p>延迟队列的实现有两种方式：</p><p>通过消息过期后进入死信交换器，再由交换器转发到延迟消费队列，实现延迟功能；<br>使用 RabbitMQ-delayed-message-exchange 插件实现延迟功能。</p><h5 id="146-RabbitMQ-集群有什么用？"><a href="#146-RabbitMQ-集群有什么用？" class="headerlink" title="146. RabbitMQ 集群有什么用？"></a>146. RabbitMQ 集群有什么用？</h5><p>集群主要有以下两个用途：</p><p>高可用：某个服务器出现问题，整个 RabbitMQ 还可以继续使用；<br>高容量：集群可以承载更多的消息量。</p><h5 id="147-RabbitMQ-节点的类型有哪些？"><a href="#147-RabbitMQ-节点的类型有哪些？" class="headerlink" title="147. RabbitMQ 节点的类型有哪些？"></a>147. RabbitMQ 节点的类型有哪些？</h5><p>磁盘节点：消息会存储到磁盘。<br>内存节点：消息都存储在内存中，重启服务器消息丢失，性能高于磁盘类型。</p><h5 id="148-RabbitMQ-集群搭建需要注意哪些问题？"><a href="#148-RabbitMQ-集群搭建需要注意哪些问题？" class="headerlink" title="148. RabbitMQ 集群搭建需要注意哪些问题？"></a>148. RabbitMQ 集群搭建需要注意哪些问题？</h5><p>各节点之间使用“–link”连接，此属性不能忽略。<br>各节点使用的 erlang cookie 值必须相同，此值相当于“秘钥”的功能，用于各节点的认证。<br>整个集群中必须包含一个磁盘节点。</p><h5 id="149-RabbitMQ-每个节点是其他节点的完整拷贝吗？为什么？"><a href="#149-RabbitMQ-每个节点是其他节点的完整拷贝吗？为什么？" class="headerlink" title="149. RabbitMQ 每个节点是其他节点的完整拷贝吗？为什么？"></a>149. RabbitMQ 每个节点是其他节点的完整拷贝吗？为什么？</h5><p>不是，原因有以下两个：</p><p>存储空间的考虑：如果每个节点都拥有所有队列的完全拷贝，这样新增节点不但没有新增存储空间，反而增加了更多的冗余数据；<br>性能的考虑：如果每条消息都需要完整拷贝到每一个集群节点，那新增节点并没有提升处理消息的能力，最多是保持和单节点相同的性能甚至是更糟。</p><h5 id="150-RabbitMQ-集群中唯一一个磁盘节点崩溃了会发生什么情况？"><a href="#150-RabbitMQ-集群中唯一一个磁盘节点崩溃了会发生什么情况？" class="headerlink" title="150. RabbitMQ 集群中唯一一个磁盘节点崩溃了会发生什么情况？"></a>150. RabbitMQ 集群中唯一一个磁盘节点崩溃了会发生什么情况？</h5><p>如果唯一磁盘的磁盘节点崩溃了，不能进行以下操作：</p><p>不能创建队列<br>不能创建交换器<br>不能创建绑定<br>不能添加用户<br>不能更改权限<br>不能添加和删除集群节点<br>唯一磁盘节点崩溃了，集群是可以保持运行的，但你不能更改任何东西。</p><h5 id="151-RabbitMQ-对集群节点停止顺序有要求吗？"><a href="#151-RabbitMQ-对集群节点停止顺序有要求吗？" class="headerlink" title="151. RabbitMQ 对集群节点停止顺序有要求吗？"></a>151. RabbitMQ 对集群节点停止顺序有要求吗？</h5><p>RabbitMQ 对集群的停止的顺序是有要求的，应该先关闭内存节点，最后再关闭磁盘节点。如果顺序恰好相反的话，可能会造成消息的丢失。</p><h3 id="Kafka"><a href="#Kafka" class="headerlink" title="Kafka"></a>Kafka</h3><h5 id="152-kafka-可以脱离-zookeeper-单独使用吗？为什么？"><a href="#152-kafka-可以脱离-zookeeper-单独使用吗？为什么？" class="headerlink" title="152. kafka 可以脱离 zookeeper 单独使用吗？为什么？"></a>152. kafka 可以脱离 zookeeper 单独使用吗？为什么？</h5><p>kafka 不能脱离 zookeeper 单独使用，因为 kafka 使用 zookeeper 管理和协调 kafka 的节点服务器。</p><h5 id="153-kafka-有几种数据保留的策略？"><a href="#153-kafka-有几种数据保留的策略？" class="headerlink" title="153. kafka 有几种数据保留的策略？"></a>153. kafka 有几种数据保留的策略？</h5><p>kafka 有两种数据保存策略：按照过期时间保留和按照存储的消息大小保留。</p><h5 id="154-kafka-同时设置了-7-天和-10G-清除数据，到第五天的时候消息达到了-10G，这个时候-kafka-将如何处理？"><a href="#154-kafka-同时设置了-7-天和-10G-清除数据，到第五天的时候消息达到了-10G，这个时候-kafka-将如何处理？" class="headerlink" title="154. kafka 同时设置了 7 天和 10G 清除数据，到第五天的时候消息达到了 10G，这个时候 kafka 将如何处理？"></a>154. kafka 同时设置了 7 天和 10G 清除数据，到第五天的时候消息达到了 10G，这个时候 kafka 将如何处理？</h5><p>这个时候 kafka 会执行数据清除工作，时间和大小不论那个满足条件，都会清空数据。</p><h5 id="155-什么情况会导致-kafka-运行变慢？"><a href="#155-什么情况会导致-kafka-运行变慢？" class="headerlink" title="155. 什么情况会导致 kafka 运行变慢？"></a>155. 什么情况会导致 kafka 运行变慢？</h5><p>cpu 性能瓶颈<br>磁盘读写瓶颈<br>网络瓶颈</p><h5 id="156-使用-kafka-集群需要注意什么？"><a href="#156-使用-kafka-集群需要注意什么？" class="headerlink" title="156. 使用 kafka 集群需要注意什么？"></a>156. 使用 kafka 集群需要注意什么？</h5><p>集群的数量不是越多越好，最好不要超过 7 个，因为节点越多，消息复制需要的时间就越长，整个群组的吞吐量就越低。<br>集群数量最好是单数，因为超过一半故障集群就不能用了，设置为单数容错率更高。</p><h3 id="Zookeeper"><a href="#Zookeeper" class="headerlink" title="Zookeeper"></a>Zookeeper</h3><h5 id="157-zookeeper-是什么？"><a href="#157-zookeeper-是什么？" class="headerlink" title="157. zookeeper 是什么？"></a>157. zookeeper 是什么？</h5><p>zookeeper 是一个分布式的，开放源码的分布式应用程序协调服务，是 google chubby 的开源实现，是 hadoop 和 hbase 的重要组件。它是一个为分布式应用提供一致性服务的软件，提供的功能包括：配置维护、域名服务、分布式同步、组服务等。</p><h5 id="158-zookeeper-都有哪些功能？"><a href="#158-zookeeper-都有哪些功能？" class="headerlink" title="158. zookeeper 都有哪些功能？"></a>158. zookeeper 都有哪些功能？</h5><p>集群管理：监控节点存活状态、运行请求等。<br>主节点选举：主节点挂掉了之后可以从备用的节点开始新一轮选主，主节点选举说的就是这个选举的过程，使用 zookeeper 可以协助完成这个过程。<br>分布式锁：zookeeper 提供两种锁：独占锁、共享锁。独占锁即一次只能有一个线程使用资源，共享锁是读锁共享，读写互斥，即可以有多线线程同时读同一个资源，如果要使用写锁也只能有一个线程使用。zookeeper可以对分布式锁进行控制。<br>命名服务：在分布式系统中，通过使用命名服务，客户端应用能够根据指定名字来获取资源或服务的地址，提供者等信息。</p><h5 id="159-zookeeper-有几种部署模式？"><a href="#159-zookeeper-有几种部署模式？" class="headerlink" title="159. zookeeper 有几种部署模式？"></a>159. zookeeper 有几种部署模式？</h5><p>zookeeper 有三种部署模式：</p><p>单机部署：一台集群上运行；<br>集群部署：多台集群运行；<br>伪集群部署：一台集群启动多个 zookeeper 实例运行。</p><h5 id="160-zookeeper-怎么保证主从节点的状态同步？"><a href="#160-zookeeper-怎么保证主从节点的状态同步？" class="headerlink" title="160. zookeeper 怎么保证主从节点的状态同步？"></a>160. zookeeper 怎么保证主从节点的状态同步？</h5><p>zookeeper 的核心是原子广播，这个机制保证了各个 server 之间的同步。实现这个机制的协议叫做 zab 协议。 zab 协议有两种模式，分别是恢复模式（选主）和广播模式（同步）。当服务启动或者在领导者崩溃后，zab 就进入了恢复模式，当领导者被选举出来，且大多数 server 完成了和 leader 的状态同步以后，恢复模式就结束了。状态同步保证了 leader 和 server 具有相同的系统状态。</p><h5 id="161-集群中为什么要有主节点？"><a href="#161-集群中为什么要有主节点？" class="headerlink" title="161. 集群中为什么要有主节点？"></a>161. 集群中为什么要有主节点？</h5><p>在分布式环境中，有些业务逻辑只需要集群中的某一台机器进行执行，其他的机器可以共享这个结果，这样可以大大减少重复计算，提高性能，所以就需要主节点。</p><h5 id="162-集群中有-3-台服务器，其中一个节点宕机，这个时候-zookeeper-还可以使用吗？"><a href="#162-集群中有-3-台服务器，其中一个节点宕机，这个时候-zookeeper-还可以使用吗？" class="headerlink" title="162. 集群中有 3 台服务器，其中一个节点宕机，这个时候 zookeeper 还可以使用吗？"></a>162. 集群中有 3 台服务器，其中一个节点宕机，这个时候 zookeeper 还可以使用吗？</h5><p>可以继续使用，单数服务器只要没超过一半的服务器宕机就可以继续使用。</p><h5 id="163-说一下-zookeeper-的通知机制？"><a href="#163-说一下-zookeeper-的通知机制？" class="headerlink" title="163. 说一下 zookeeper 的通知机制？"></a>163. 说一下 zookeeper 的通知机制？</h5><p>客户端端会对某个 znode 建立一个 watcher 事件，当该 znode 发生变化时，这些客户端会收到 zookeeper 的通知，然后客户端可以根据 znode 变化来做出业务上的改变。</p><h3 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h3><h5 id="164-数据库的三范式是什么？"><a href="#164-数据库的三范式是什么？" class="headerlink" title="164. 数据库的三范式是什么？"></a>164. 数据库的三范式是什么？</h5><p>第一范式：强调的是列的原子性，即数据库表的每一列都是不可分割的原子数据项。<br>第二范式：要求实体的属性完全依赖于主关键字。所谓完全依赖是指不能存在仅依赖主关键字一部分的属性。<br>第三范式：任何非主属性不依赖于其它非主属性。</p><h5 id="165-一张自增表里面总共有-7-条数据，删除了最后-2-条数据，重启-MySQL-数据库，又插入了一条数据，此时-id-是几？"><a href="#165-一张自增表里面总共有-7-条数据，删除了最后-2-条数据，重启-MySQL-数据库，又插入了一条数据，此时-id-是几？" class="headerlink" title="165. 一张自增表里面总共有 7 条数据，删除了最后 2 条数据，重启 MySQL 数据库，又插入了一条数据，此时 id 是几？"></a>165. 一张自增表里面总共有 7 条数据，删除了最后 2 条数据，重启 MySQL 数据库，又插入了一条数据，此时 id 是几？</h5><p>表类型如果是 MyISAM ，那 id 就是 8。<br>表类型如果是 InnoDB，那 id 就是 6。<br>InnoDB 表只会把自增主键的最大 id 记录在内存中，所以重启之后会导致最大 id 丢失。</p><h5 id="166-如何获取当前数据库版本？"><a href="#166-如何获取当前数据库版本？" class="headerlink" title="166. 如何获取当前数据库版本？"></a>166. 如何获取当前数据库版本？</h5><p>使用 select version() 获取当前 MySQL 数据库版本。</p><h5 id="167-说一下-ACID-是什么？"><a href="#167-说一下-ACID-是什么？" class="headerlink" title="167. 说一下 ACID 是什么？"></a>167. 说一下 ACID 是什么？</h5><p>Atomicity（原子性）：一个事务（transaction）中的所有操作，或者全部完成，或者全部不完成，不会结束在中间某个环节。事务在执行过程中发生错误，会被恢复（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。即，事务不可分割、不可约简。<br>Consistency（一致性）：在事务开始之前和事务结束以后，数据库的完整性没有被破坏。这表示写入的资料必须完全符合所有的预设约束、触发器、级联回滚等。<br>Isolation（隔离性）：数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。事务隔离分为不同级别，包括读未提交（Read uncommitted）、读提交（read committed）、可重复读（repeatable read）和串行化（Serializable）。<br>Durability（持久性）：事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。</p><h5 id="168-char-和-varchar-的区别是什么？"><a href="#168-char-和-varchar-的区别是什么？" class="headerlink" title="168. char 和 varchar 的区别是什么？"></a>168. char 和 varchar 的区别是什么？</h5><p>char(n) ：固定长度类型，比如订阅 char(10)，当你输入”abc”三个字符的时候，它们占的空间还是 10 个字节，其他 7 个是空字节。<br>chat 优点：效率高；缺点：占用空间；适用场景：存储密码的 md5 值，固定长度的，使用 char 非常合适。</p><p>varchar(n) ：可变长度，存储的值是每个值占用的字节再加上一个用来记录其长度的字节的长度。<br>所以，从空间上考虑 varcahr 比较合适；从效率上考虑 char 比较合适，二者使用需要权衡。</p><h5 id="169-float-和-double-的区别是什么？"><a href="#169-float-和-double-的区别是什么？" class="headerlink" title="169. float 和 double 的区别是什么？"></a>169. float 和 double 的区别是什么？</h5><p>float 最多可以存储 8 位的十进制数，并在内存中占 4 字节。<br>double 最可可以存储 16 位的十进制数，并在内存中占 8 字节。</p><h5 id="170-MySQL-的内连接、左连接、右连接有什么区别？"><a href="#170-MySQL-的内连接、左连接、右连接有什么区别？" class="headerlink" title="170. MySQL 的内连接、左连接、右连接有什么区别？"></a>170. MySQL 的内连接、左连接、右连接有什么区别？</h5><p>内连接关键字：inner join；左连接：left join；右连接：right join。</p><p>内连接是把匹配的关联数据显示出来；左连接是左边的表全部显示出来，右边的表显示出符合条件的数据；右连接正好相反。</p><h5 id="171-MySQL-索引是怎么实现的？"><a href="#171-MySQL-索引是怎么实现的？" class="headerlink" title="171. MySQL 索引是怎么实现的？"></a>171. MySQL 索引是怎么实现的？</h5><p>索引是满足某种特定查找算法的数据结构，而这些数据结构会以某种方式指向数据，从而实现高效查找数据。</p><p>具体来说 MySQL 中的索引，不同的数据引擎实现有所不同，但目前主流的数据库引擎的索引都是 B+ 树实现的，B+ 树的搜索效率，可以到达二分法的性能，找到数据区域之后就找到了完整的数据结构了，所有索引的性能也是更好的。</p><h5 id="172-怎么验证-MySQL-的索引是否满足需求？"><a href="#172-怎么验证-MySQL-的索引是否满足需求？" class="headerlink" title="172. 怎么验证 MySQL 的索引是否满足需求？"></a>172. 怎么验证 MySQL 的索引是否满足需求？</h5><p>使用 explain 查看 SQL 是如何执行查询语句的，从而分析你的索引是否满足需求。</p><p>explain 语法：explain select * from table where type=1。</p><h5 id="173-说一下数据库的事务隔离？"><a href="#173-说一下数据库的事务隔离？" class="headerlink" title="173. 说一下数据库的事务隔离？"></a>173. 说一下数据库的事务隔离？</h5><p>MySQL 的事务隔离是在 MySQL. ini 配置文件里添加的，在文件的最后添加：</p><p>transaction-isolation = REPEATABLE-READ<br>可用的配置值：READ-UNCOMMITTED、READ-COMMITTED、REPEATABLE-READ、SERIALIZABLE。</p><p>READ-UNCOMMITTED：未提交读，最低隔离级别、事务未提交前，就可被其他事务读取（会出现幻读、脏读、不可重复读）。<br>READ-COMMITTED：提交读，一个事务提交后才能被其他事务读取到（会造成幻读、不可重复读）。<br>REPEATABLE-READ：可重复读，默认级别，保证多次读取同一个数据时，其值都和事务开始时候的内容是一致，禁止读取到别的事务未提交的数据（会造成幻读）。<br>SERIALIZABLE：序列化，代价最高最可靠的隔离级别，该隔离级别能防止脏读、不可重复读、幻读。<br>脏读 ：表示一个事务能够读取另一个事务中还未提交的数据。比如，某个事务尝试插入记录 A，此时该事务还未提交，然后另一个事务尝试读取到了记录 A。</p><p>不可重复读 ：是指在一个事务内，多次读同一数据。</p><p>幻读 ：指同一个事务内多次查询返回的结果集不一样。比如同一个事务 A 第一次查询时候有 n 条记录，但是第二次同等条件下查询却有 n+1 条记录，这就好像产生了幻觉。发生幻读的原因也是另外一个事务新增或者删除或者修改了第一个事务结果集里面的数据，同一个记录的数据内容被修改了，所有数据行的记录就变多或者变少了。</p><h5 id="174-说一下-MySQL-常用的引擎？"><a href="#174-说一下-MySQL-常用的引擎？" class="headerlink" title="174. 说一下 MySQL 常用的引擎？"></a>174. 说一下 MySQL 常用的引擎？</h5><p>InnoDB 引擎：InnoDB 引擎提供了对数据库 acid 事务的支持，并且还提供了行级锁和外键的约束，它的设计的目标就是处理大数据容量的数据库系统。MySQL 运行的时候，InnoDB 会在内存中建立缓冲池，用于缓冲数据和索引。但是该引擎是不支持全文搜索，同时启动也比较的慢，它是不会保存表的行数的，所以当进行 select count(*) from table 指令的时候，需要进行扫描全表。由于锁的粒度小，写操作是不会锁定全表的,所以在并发度较高的场景下使用会提升效率的。</p><p>MyIASM 引擎：MySQL 的默认引擎，但不提供事务的支持，也不支持行级锁和外键。因此当执行插入和更新语句时，即执行写操作的时候需要锁定这个表，所以会导致效率会降低。不过和 InnoDB 不同的是，MyIASM 引擎是保存了表的行数，于是当进行 select count(*) from table 语句时，可以直接的读取已经保存的值而不需要进行扫描全表。所以，如果表的读操作远远多于写操作时，并且不需要事务的支持的，可以将 MyIASM 作为数据库引擎的首选。</p><h5 id="175-说一下-MySQL-的行锁和表锁？"><a href="#175-说一下-MySQL-的行锁和表锁？" class="headerlink" title="175. 说一下 MySQL 的行锁和表锁？"></a>175. 说一下 MySQL 的行锁和表锁？</h5><p>MyISAM 只支持表锁，InnoDB 支持表锁和行锁，默认为行锁。</p><p>表级锁：开销小，加锁快，不会出现死锁。锁定粒度大，发生锁冲突的概率最高，并发量最低。<br>行级锁：开销大，加锁慢，会出现死锁。锁力度小，发生锁冲突的概率小，并发度最高。</p><h5 id="176-说一下乐观锁和悲观锁？"><a href="#176-说一下乐观锁和悲观锁？" class="headerlink" title="176. 说一下乐观锁和悲观锁？"></a>176. 说一下乐观锁和悲观锁？</h5><p>乐观锁：每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在提交更新的时候会判断一下在此期间别人有没有去更新这个数据。<br>悲观锁：每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻止，直到这个锁被释放。<br>数据库的乐观锁需要自己实现，在表里面添加一个 version 字段，每次修改成功值加 1，这样每次修改的时候先对比一下，自己拥有的 version 和数据库现在的 version 是否一致，如果不一致就不修改，这样就实现了乐观锁。</p><h5 id="177-MySQL-问题排查都有哪些手段？"><a href="#177-MySQL-问题排查都有哪些手段？" class="headerlink" title="177. MySQL 问题排查都有哪些手段？"></a>177. MySQL 问题排查都有哪些手段？</h5><p>使用 show processlist 命令查看当前所有连接信息。<br>使用 explain 命令查询 SQL 语句执行计划。<br>开启慢查询日志，查看慢查询的 SQL。</p><h5 id="178-如何做-MySQL-的性能优化？"><a href="#178-如何做-MySQL-的性能优化？" class="headerlink" title="178. 如何做 MySQL 的性能优化？"></a>178. 如何做 MySQL 的性能优化？</h5><p>为搜索字段创建索引。<br>避免使用 select *，列出需要查询的字段。<br>垂直分割分表。<br>选择正确的存储引擎。</p><h3 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h3><h5 id="179-Redis-是什么？都有哪些使用场景？"><a href="#179-Redis-是什么？都有哪些使用场景？" class="headerlink" title="179. Redis 是什么？都有哪些使用场景？"></a>179. Redis 是什么？都有哪些使用场景？</h5><p>Redis 是一个使用 C 语言开发的高速缓存数据库。</p><p>Redis 使用场景：</p><p>记录帖子点赞数、点击数、评论数；<br>缓存近期热帖；<br>缓存文章详情信息；<br>记录用户会话信息。</p><h5 id="180-Redis-有哪些功能？"><a href="#180-Redis-有哪些功能？" class="headerlink" title="180. Redis 有哪些功能？"></a>180. Redis 有哪些功能？</h5><p>数据缓存功能<br>分布式锁的功能<br>支持数据持久化<br>支持事务<br>支持消息队列</p><h5 id="181-Redis-和-memcache-有什么区别？"><a href="#181-Redis-和-memcache-有什么区别？" class="headerlink" title="181. Redis 和 memcache 有什么区别？"></a>181. Redis 和 memcache 有什么区别？</h5><p>存储方式不同：memcache 把数据全部存在内存之中，断电后会挂掉，数据不能超过内存大小；Redis 有部份存在硬盘上，这样能保证数据的持久性。<br>数据支持类型：memcache 对数据类型支持相对简单；Redis 有复杂的数据类型。<br>使用底层模型不同：它们之间底层实现方式，以及与客户端之间通信的应用协议不一样，Redis 自己构建了 vm 机制，因为一般的系统调用系统函数的话，会浪费一定的时间去移动和请求。<br>value 值大小不同：Redis 最大可以达到 1gb；memcache 只有 1mb。</p><h5 id="182-Redis-为什么是单线程的？"><a href="#182-Redis-为什么是单线程的？" class="headerlink" title="182. Redis 为什么是单线程的？"></a>182. Redis 为什么是单线程的？</h5><p>因为 cpu 不是 Redis 的瓶颈，Redis 的瓶颈最有可能是机器内存或者网络带宽。既然单线程容易实现，而且 cpu 又不会成为瓶颈，那就顺理成章地采用单线程的方案了。</p><p>关于 Redis 的性能，官方网站也有，普通笔记本轻松处理每秒几十万的请求。</p><p>而且单线程并不代表就慢 nginx 和 nodejs 也都是高性能单线程的代表。</p><h5 id="183-什么是缓存穿透？怎么解决？"><a href="#183-什么是缓存穿透？怎么解决？" class="headerlink" title="183. 什么是缓存穿透？怎么解决？"></a>183. 什么是缓存穿透？怎么解决？</h5><p>缓存穿透：指查询一个一定不存在的数据，由于缓存是不命中时需要从数据库查询，查不到数据则不写入缓存，这将导致这个不存在的数据每次请求都要到数据库去查询，造成缓存穿透。</p><p>解决方案：最简单粗暴的方法如果一个查询返回的数据为空（不管是数据不存在，还是系统故障），我们就把这个空结果进行缓存，但它的过期时间会很短，最长不超过五分钟。</p><h5 id="184-Redis-支持的数据类型有哪些？"><a href="#184-Redis-支持的数据类型有哪些？" class="headerlink" title="184. Redis 支持的数据类型有哪些？"></a>184. Redis 支持的数据类型有哪些？</h5><p>Redis 支持的数据类型：string（字符串）、list（列表）、hash（字典）、set（集合）、zset（有序集合）。</p><h5 id="185-Redis-支持的-Java-客户端都有哪些？"><a href="#185-Redis-支持的-Java-客户端都有哪些？" class="headerlink" title="185. Redis 支持的 Java 客户端都有哪些？"></a>185. Redis 支持的 Java 客户端都有哪些？</h5><p>支持的 Java 客户端有 Redisson、jedis、lettuce 等。</p><h5 id="186-jedis-和-Redisson-有哪些区别？"><a href="#186-jedis-和-Redisson-有哪些区别？" class="headerlink" title="186. jedis 和 Redisson 有哪些区别？"></a>186. jedis 和 Redisson 有哪些区别？</h5><p>jedis：提供了比较全面的 Redis 命令的支持。<br>Redisson：实现了分布式和可扩展的 Java 数据结构，与 jedis 相比 Redisson 的功能相对简单，不支持排序、事务、管道、分区等 Redis 特性。</p><h5 id="187-怎么保证缓存和数据库数据的一致性？"><a href="#187-怎么保证缓存和数据库数据的一致性？" class="headerlink" title="187. 怎么保证缓存和数据库数据的一致性？"></a>187. 怎么保证缓存和数据库数据的一致性？</h5><p>合理设置缓存的过期时间。<br>新增、更改、删除数据库操作时同步更新 Redis，可以使用事物机制来保证数据的一致性。</p><h5 id="188-Redis-持久化有几种方式？"><a href="#188-Redis-持久化有几种方式？" class="headerlink" title="188. Redis 持久化有几种方式？"></a>188. Redis 持久化有几种方式？</h5><p>Redis 的持久化有两种方式，或者说有两种策略：</p><p>RDB（Redis Database）：指定的时间间隔能对你的数据进行快照存储。<br>AOF（Append Only File）：每一个收到的写命令都通过write函数追加到文件中。</p><h5 id="189-Redis-怎么实现分布式锁？"><a href="#189-Redis-怎么实现分布式锁？" class="headerlink" title="189. Redis 怎么实现分布式锁？"></a>189. Redis 怎么实现分布式锁？</h5><p>Redis 分布式锁其实就是在系统里面占一个“坑”，其他程序也要占“坑”的时候，占用成功了就可以继续执行，失败了就只能放弃或稍后重试。</p><p>占坑一般使用 setnx(set if not exists)指令，只允许被一个程序占有，使用完调用 del 释放锁。</p><h5 id="190-Redis-分布式锁有什么缺陷？"><a href="#190-Redis-分布式锁有什么缺陷？" class="headerlink" title="190. Redis 分布式锁有什么缺陷？"></a>190. Redis 分布式锁有什么缺陷？</h5><p>Redis 分布式锁不能解决超时的问题，分布式锁有一个超时时间，程序的执行如果超出了锁的超时时间就会出现问题。</p><h5 id="191-Redis-如何做内存优化？"><a href="#191-Redis-如何做内存优化？" class="headerlink" title="191. Redis 如何做内存优化？"></a>191. Redis 如何做内存优化？</h5><p>尽量使用 Redis 的散列表，把相关的信息放到散列表里面存储，而不是把每个字段单独存储，这样可以有效的减少内存使用。比如将 Web 系统的用户对象，应该放到散列表里面再整体存储到 Redis，而不是把用户的姓名、年龄、密码、邮箱等字段分别设置 key 进行存储。</p><h5 id="192-Redis-淘汰策略有哪些？"><a href="#192-Redis-淘汰策略有哪些？" class="headerlink" title="192. Redis 淘汰策略有哪些？"></a>192. Redis 淘汰策略有哪些？</h5><p>volatile-lru：从已设置过期时间的数据集（server. db[i]. expires）中挑选最近最少使用的数据淘汰。</p><p>volatile-ttl：从已设置过期时间的数据集（server. db[i]. expires）中挑选将要过期的数据淘汰。</p><p>volatile-random：从已设置过期时间的数据集（server. db[i]. expires）中任意选择数据淘汰。</p><p>allkeys-lru：从数据集（server. db[i]. dict）中挑选最近最少使用的数据淘汰。</p><p>allkeys-random：从数据集（server. db[i]. dict）中任意选择数据淘汰。</p><p>no-enviction（驱逐）：禁止驱逐数据。</p><h5 id="193-Redis-常见的性能问题有哪些？该如何解决？"><a href="#193-Redis-常见的性能问题有哪些？该如何解决？" class="headerlink" title="193. Redis 常见的性能问题有哪些？该如何解决？"></a>193. Redis 常见的性能问题有哪些？该如何解决？</h5><p>主服务器写内存快照，会阻塞主线程的工作，当快照比较大时对性能影响是非常大的，会间断性暂停服务，所以主服务器最好不要写内存快照。<br>Redis 主从复制的性能问题，为了主从复制的速度和连接的稳定性，主从库最好在同一个局域网内。</p><h3 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h3><h5 id="194-说一下-JVM-的主要组成部分？及其作用？"><a href="#194-说一下-JVM-的主要组成部分？及其作用？" class="headerlink" title="194. 说一下 JVM 的主要组成部分？及其作用？"></a>194. 说一下 JVM 的主要组成部分？及其作用？</h5><p>类加载器（ClassLoader）<br>运行时数据区（Runtime Data Area）<br>执行引擎（Execution Engine）<br>本地库接口（Native Interface）<br>组件的作用： 首先通过类加载器（ClassLoader）会把 Java 代码转换成字节码，运行时数据区（Runtime Data Area）再把字节码加载到内存中，而字节码文件只是 JVM 的一套指令集规范，并不能直接交个底层操作系统去执行，因此需要特定的命令解析器执行引擎（Execution Engine），将字节码翻译成底层系统指令，再交由 CPU 去执行，而这个过程中需要调用其他语言的本地库接口（Native Interface）来实现整个程序的功能。</p><h5 id="195-说一下-JVM-运行时数据区？"><a href="#195-说一下-JVM-运行时数据区？" class="headerlink" title="195. 说一下 JVM 运行时数据区？"></a>195. 说一下 JVM 运行时数据区？</h5><p>不同虚拟机的运行时数据区可能略微有所不同，但都会遵从 Java 虚拟机规范， Java 虚拟机规范规定的区域分为以下 5 个部分：</p><p>程序计数器（Program Counter Register）：当前线程所执行的字节码的行号指示器，字节码解析器的工作是通过改变这个计数器的值，来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能，都需要依赖这个计数器来完成；</p><p>Java 虚拟机栈（Java Virtual Machine Stacks）：用于存储局部变量表、操作数栈、动态链接、方法出口等信息；</p><p>本地方法栈（Native Method Stack）：与虚拟机栈的作用是一样的，只不过虚拟机栈是服务 Java 方法的，而本地方法栈是为虚拟机调用 Native 方法服务的；</p><p>Java 堆（Java Heap）：Java 虚拟机中内存最大的一块，是被所有线程共享的，几乎所有的对象实例都在这里分配内存；</p><p>方法区（Methed Area）：用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译后的代码等数据。</p><h5 id="196-说一下堆栈的区别？"><a href="#196-说一下堆栈的区别？" class="headerlink" title="196. 说一下堆栈的区别？"></a>196. 说一下堆栈的区别？</h5><p>功能方面：堆是用来存放对象的，栈是用来执行程序的。<br>共享性：堆是线程共享的，栈是线程私有的。<br>空间大小：堆大小远远大于栈。</p><h5 id="197-队列和栈是什么？有什么区别？"><a href="#197-队列和栈是什么？有什么区别？" class="headerlink" title="197. 队列和栈是什么？有什么区别？"></a>197. 队列和栈是什么？有什么区别？</h5><p>队列和栈都是被用来预存储数据的。</p><p>队列允许先进先出检索元素，但也有例外的情况，Deque 接口允许从两端检索元素。</p><p>栈和队列很相似，但它运行对元素进行后进先出进行检索。</p><h5 id="198-什么是双亲委派模型？"><a href="#198-什么是双亲委派模型？" class="headerlink" title="198. 什么是双亲委派模型？"></a>198. 什么是双亲委派模型？</h5><p>在介绍双亲委派模型之前先说下类加载器。对于任意一个类，都需要由加载它的类加载器和这个类本身一同确立在 JVM 中的唯一性，每一个类加载器，都有一个独立的类名称空间。类加载器就是根据指定全限定名称将 class 文件加载到 JVM 内存，然后再转化为 class 对象。</p><p>类加载器分类：</p><p>启动类加载器（Bootstrap ClassLoader），是虚拟机自身的一部分，用来加载Java_HOME/lib/目录中的，或者被 -Xbootclasspath 参数所指定的路径中并且被虚拟机识别的类库；<br>其他类加载器：<br>扩展类加载器（Extension ClassLoader）：负责加载<br>\lib\ext目录或Java. ext. dirs系统变量指定的路径中的所有类库；<br>应用程序类加载器（Application ClassLoader）。负责加载用户类路径（classpath）上的指定类库，我们可以直接使用这个类加载器。一般情况，如果我们没有自定义类加载器默认就是用这个加载器。<br>双亲委派模型：如果一个类加载器收到了类加载的请求，它首先不会自己去加载这个类，而是把这个请求委派给父类加载器去完成，每一层的类加载器都是如此，这样所有的加载请求都会被传送到顶层的启动类加载器中，只有当父加载无法完成加载请求（它的搜索范围中没找到所需的类）时，子加载器才会尝试去加载类。</p><h5 id="199-说一下类装载的执行过程？"><a href="#199-说一下类装载的执行过程？" class="headerlink" title="199. 说一下类装载的执行过程？"></a>199. 说一下类装载的执行过程？</h5><p>类装载分为以下 5 个步骤：</p><p>加载：根据查找路径找到相应的 class 文件然后导入；<br>检查：检查加载的 class 文件的正确性；<br>准备：给类中的静态变量分配内存空间；<br>解析：虚拟机将常量池中的符号引用替换成直接引用的过程。符号引用就理解为一个标示，而在直接引用直接指向内存中的地址；<br>初始化：对静态变量和静态代码块执行初始化工作。</p><h5 id="200-怎么判断对象是否可以被回收？"><a href="#200-怎么判断对象是否可以被回收？" class="headerlink" title="200. 怎么判断对象是否可以被回收？"></a>200. 怎么判断对象是否可以被回收？</h5><p>一般有两种方法来判断：</p><p>引用计数器：为每个对象创建一个引用计数，有对象引用时计数器 +1，引用被释放时计数 -1，当计数器为 0 时就可以被回收。它有一个缺点不能解决循环引用的问题；<br>可达性分析：从 GC Roots 开始向下搜索，搜索所走过的路径称为引用链。当一个对象到 GC Roots 没有任何引用链相连时，则证明此对象是可以被回收的。</p><h5 id="201-Java-中都有哪些引用类型？"><a href="#201-Java-中都有哪些引用类型？" class="headerlink" title="201. Java 中都有哪些引用类型？"></a>201. Java 中都有哪些引用类型？</h5><p>强引用：发生 gc 的时候不会被回收。<br>软引用：有用但不是必须的对象，在发生内存溢出之前会被回收。<br>弱引用：有用但不是必须的对象，在下一次GC时会被回收。<br>虚引用（幽灵引用/幻影引用）：无法通过虚引用获得对象，用 PhantomReference 实现虚引用，虚引用的用途是在 gc 时返回一个通知。</p><h5 id="202-说一下-JVM-有哪些垃圾回收算法？"><a href="#202-说一下-JVM-有哪些垃圾回收算法？" class="headerlink" title="202. 说一下 JVM 有哪些垃圾回收算法？"></a>202. 说一下 JVM 有哪些垃圾回收算法？</h5><p>标记-清除算法：标记无用对象，然后进行清除回收。缺点：效率不高，无法清除垃圾碎片。<br>标记-整理算法：标记无用对象，让所有存活的对象都向一端移动，然后直接清除掉端边界以外的内存。<br>复制算法：按照容量划分二个大小相等的内存区域，当一块用完的时候将活着的对象复制到另一块上，然后再把已使用的内存空间一次清理掉。缺点：内存使用率不高，只有原来的一半。<br>分代算法：根据对象存活周期的不同将内存划分为几块，一般是新生代和老年代，新生代基本采用复制算法，老年代采用标记整理算法。</p><h5 id="203-说一下-JVM-有哪些垃圾回收器？"><a href="#203-说一下-JVM-有哪些垃圾回收器？" class="headerlink" title="203. 说一下 JVM 有哪些垃圾回收器？"></a>203. 说一下 JVM 有哪些垃圾回收器？</h5><p>Serial：最早的单线程串行垃圾回收器。<br>Serial Old：Serial 垃圾回收器的老年版本，同样也是单线程的，可以作为 CMS 垃圾回收器的备选预案。<br>ParNew：是 Serial 的多线程版本。<br>Parallel 和 ParNew 收集器类似是多线程的，但 Parallel 是吞吐量优先的收集器，可以牺牲等待时间换取系统的吞吐量。<br>Parallel Old 是 Parallel 老生代版本，Parallel 使用的是复制的内存回收算法，Parallel Old 使用的是标记-整理的内存回收算法。<br>CMS：一种以获得最短停顿时间为目标的收集器，非常适用 B/S 系统。<br>G1：一种兼顾吞吐量和停顿时间的 GC 实现，是 JDK 9 以后的默认 GC 选项。</p><h5 id="204-详细介绍一下-CMS-垃圾回收器？"><a href="#204-详细介绍一下-CMS-垃圾回收器？" class="headerlink" title="204. 详细介绍一下 CMS 垃圾回收器？"></a>204. 详细介绍一下 CMS 垃圾回收器？</h5><p>CMS 是英文 Concurrent Mark-Sweep 的简称，是以牺牲吞吐量为代价来获得最短回收停顿时间的垃圾回收器。对于要求服务器响应速度的应用上，这种垃圾回收器非常适合。在启动 JVM 的参数加上“-XX:+UseConcMarkSweepGC”来指定使用 CMS 垃圾回收器。</p><p>CMS 使用的是标记-清除的算法实现的，所以在 gc 的时候回产生大量的内存碎片，当剩余内存不能满足程序运行要求时，系统将会出现 Concurrent Mode Failure，临时 CMS 会采用 Serial Old 回收器进行垃圾清除，此时的性能将会被降低。</p><h5 id="205-新生代垃圾回收器和老生代垃圾回收器都有哪些？有什么区别？"><a href="#205-新生代垃圾回收器和老生代垃圾回收器都有哪些？有什么区别？" class="headerlink" title="205. 新生代垃圾回收器和老生代垃圾回收器都有哪些？有什么区别？"></a>205. 新生代垃圾回收器和老生代垃圾回收器都有哪些？有什么区别？</h5><p>新生代回收器：Serial、ParNew、Parallel Scavenge<br>老年代回收器：Serial Old、Parallel Old、CMS<br>整堆回收器：G1<br>新生代垃圾回收器一般采用的是复制算法，复制算法的优点是效率高，缺点是内存利用率低；老年代回收器一般采用的是标记-整理的算法进行垃圾回收。</p><h5 id="206-简述分代垃圾回收器是怎么工作的？"><a href="#206-简述分代垃圾回收器是怎么工作的？" class="headerlink" title="206. 简述分代垃圾回收器是怎么工作的？"></a>206. 简述分代垃圾回收器是怎么工作的？</h5><p>分代回收器有两个分区：老生代和新生代，新生代默认的空间占比总空间的 1/3，老生代的默认占比是 2/3。</p><p>新生代使用的是复制算法，新生代里有 3 个分区：Eden、To Survivor、From Survivor，它们的默认占比是 8:1:1，它的执行流程如下：</p><p>把 Eden + From Survivor 存活的对象放入 To Survivor 区；<br>清空 Eden 和 From Survivor 分区；<br>From Survivor 和 To Survivor 分区交换，From Survivor 变 To Survivor，To Survivor 变 From Survivor。<br>每次在 From Survivor 到 To Survivor 移动时都存活的对象，年龄就 +1，当年龄到达 15（默认配置是 15）时，升级为老生代。大对象也会直接进入老生代。</p><p>老生代当空间占用到达某个值之后就会触发全局垃圾收回，一般使用标记整理的执行算法。以上这些循环往复就构成了整个分代垃圾回收的整体执行流程。</p><h5 id="207-说一下-JVM-调优的工具？"><a href="#207-说一下-JVM-调优的工具？" class="headerlink" title="207. 说一下 JVM 调优的工具？"></a>207. 说一下 JVM 调优的工具？</h5><p>JDK 自带了很多监控工具，都位于 JDK 的 bin 目录下，其中最常用的是 jconsole 和 jvisualvm 这两款视图监控工具。</p><p>jconsole：用于对 JVM 中的内存、线程和类等进行监控；<br>jvisualvm：JDK 自带的全能分析工具，可以分析：内存快照、线程快照、程序死锁、监控内存的变化、gc 变化等。</p><ol start="208"><li>常用的 JVM 调优的参数都有哪些？</li></ol><p>-Xms2g：初始化推大小为 2g；<br>-Xmx2g：堆最大内存为 2g；<br>-XX:NewRatio=4：设置年轻的和老年代的内存比例为 1:4；<br>-XX:SurvivorRatio=8：设置新生代 Eden 和 Survivor 比例为 8:2；<br>–XX:+UseParNewGC：指定使用 ParNew + Serial Old 垃圾回收器组合；<br>-XX:+UseParallelOldGC：指定使用 ParNew + ParNew Old 垃圾回收器组合；<br>-XX:+UseConcMarkSweepGC：指定使用 CMS + Serial Old 垃圾回收器组合；<br>-XX:+PrintGC：开启打印 gc 信息；<br>-XX:+PrintGCDetails：打印 gc 详细信息。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java 面试题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ThreadPoolTaskExecutor</title>
      <link href="/2019/03/21/SpringBoot-ThreadPoolTaskExecutor%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
      <url>/2019/03/21/SpringBoot-ThreadPoolTaskExecutor%E7%BA%BF%E7%A8%8B%E6%B1%A0/</url>
      
        <content type="html"><![CDATA[<blockquote><p>ThreadPoolTaskExecutor是一个Spring的线程池技术，它是使用jdk中的java.util.concurrent.ThreadPoolExecutor进行实现。 </p></blockquote><h4 id="ThreadPoolTaskExecutor的参数："><a href="#ThreadPoolTaskExecutor的参数：" class="headerlink" title="ThreadPoolTaskExecutor的参数："></a>ThreadPoolTaskExecutor的参数：</h4><pre><code>int corePoolSize:线程池维护线程的最小数量. int maximumPoolSize:线程池维护线程的最大数量. long keepAliveTime:空闲线程的存活时间. TimeUnit unit: 时间单位,现有纳秒,微秒,毫秒,秒枚举值. BlockingQueue&lt;Runnable&gt; workQueue:持有等待执行的任务队列. RejectedExecutionHandler handler: 用来拒绝一个任务的执行，有两种情况会发生这种情况。     一是在execute方法中若addIfUnderMaximumPoolSize(command)为false，即线程池已经饱和；     二是在execute方法中, 发现runState!=RUNNING || poolSize == 0,即已经shutdown,就调用ensureQueuedTaskHandled(Runnable command)，在该方法中有可能调用reject。</code></pre><h4 id="ThredPoolTaskExcutor的处理流程："><a href="#ThredPoolTaskExcutor的处理流程：" class="headerlink" title="ThredPoolTaskExcutor的处理流程："></a>ThredPoolTaskExcutor的处理流程：</h4><pre><code>1.当池子大小小于corePoolSize，就新建线程，并处理请求2.当池子大小等于corePoolSize，把请求放入workQueue中，池子里的空闲线程就去workQueue中取任务并处理3.当workQueue放不下任务时，就新建线程入池，并处理请求，如果池子大小撑到了maximumPoolSize，就用RejectedExecutionHandler来做拒绝处理4.当池子的线程数大于corePoolSize时，多余的线程会等待keepAliveTime长时间，如果无请求可处理就自行销毁其会优先创建  CorePoolSiz 线程， 当继续增加线程时，先放入Queue中，当 CorePoolSiz  和 Queue 都满的时候，就增加创建新线程，当线程达到MaxPoolSize的时候，就会抛出错 误 org.springframework.core.task.TaskRejectedException另外MaxPoolSize的设定如果比系统支持的线程数还要大时，会抛出java.lang.OutOfMemoryError: unable to create new native thread 异常。</code></pre><h4 id="Reject策略预定义有四种："><a href="#Reject策略预定义有四种：" class="headerlink" title="Reject策略预定义有四种："></a>Reject策略预定义有四种：</h4><pre><code>(1)ThreadPoolExecutor.AbortPolicy策略，是默认的策略,处理程序遭到拒绝将抛出运行时 RejectedExecutionException。 (2)ThreadPoolExecutor.CallerRunsPolicy策略 ,调用者的线程会执行该任务,如果执行器已关闭,则丢弃. (3)ThreadPoolExecutor.DiscardPolicy策略，不能执行的任务将被丢弃. (4)ThreadPoolExecutor.DiscardOldestPolicy策略，如果执行程序尚未关闭，则位于工作队列头部的任务将被删除，然后重试执行程序（如果再次失败，则重复此过程）.</code></pre><h4 id="使用。"><a href="#使用。" class="headerlink" title="使用。"></a>使用。</h4><h5 id="SpringBoot-Config"><a href="#SpringBoot-Config" class="headerlink" title="SpringBoot  Config"></a>SpringBoot  Config</h5><h6 id="创建，初始化。"><a href="#创建，初始化。" class="headerlink" title="创建，初始化。"></a>创建，初始化。</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  默认线程池线程池</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: yangkai</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 13:59 2019/03/28</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span>: org.springframework.scheduling.concurrent.ThreadPoolTaskExecutor</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ThreadPoolTaskExecutor <span class="title">defaultThreadPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ThreadPoolTaskExecutor executor = <span class="keyword">new</span> ThreadPoolTaskExecutor();</span><br><span class="line">    <span class="comment">//核心线程数目</span></span><br><span class="line">    executor.setCorePoolSize(<span class="number">5</span>);</span><br><span class="line">    <span class="comment">//指定最大线程数</span></span><br><span class="line">    executor.setMaxPoolSize(<span class="number">15</span>);</span><br><span class="line">    <span class="comment">//队列中最大的数目</span></span><br><span class="line">    executor.setQueueCapacity(<span class="number">10</span>);</span><br><span class="line">    <span class="comment">//线程名称前缀</span></span><br><span class="line">    executor.setThreadNamePrefix(<span class="string">"apiThreadPool_"</span>);</span><br><span class="line">    <span class="comment">//rejection-policy：当pool已经达到max size的时候，如何处理新任务</span></span><br><span class="line">    <span class="comment">//CALLER_RUNS：不在新线程中执行任务，而是由调用者所在的线程来执行</span></span><br><span class="line">    <span class="comment">//对拒绝task的处理策略</span></span><br><span class="line">    executor.setRejectedExecutionHandler(<span class="keyword">new</span> ThreadPoolExecutor.CallerRunsPolicy());</span><br><span class="line">    <span class="comment">//线程空闲后的最大存活时间</span></span><br><span class="line">    executor.setKeepAliveSeconds(<span class="number">60</span>);</span><br><span class="line">    <span class="comment">//加载</span></span><br><span class="line">    executor.initialize();</span><br><span class="line">    <span class="keyword">return</span> executor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="使用方式。"><a href="#使用方式。" class="headerlink" title="使用方式。"></a>使用方式。</h6><pre><code>第一种方式：@Async 注解。    注： @Async所修饰的函数不要定义为static类型，这样异步调用不会生效第二种方式：    1.IOC 注入Bean        /** 通过注解引入配置 */        @Resource(name = &quot;defaultThreadPool&quot;)        private ThreadPoolTaskExecutor executor;    2.executor.execute(); 调用。</code></pre>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java SpringBoot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>单点登录问题</title>
      <link href="/2019/03/21/%E5%85%B3%E4%BA%8E%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95%E9%97%AE%E9%A2%98/"/>
      <url>/2019/03/21/%E5%85%B3%E4%BA%8E%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h4 id="单点登录"><a href="#单点登录" class="headerlink" title="单点登录"></a>单点登录</h4><pre><code>我觉得单点登录问题，分为两种。因为cookie不可以跨域存储和访问。</code></pre><blockquote><p>同域下。。一个用户只可以在一个地方登录。</p></blockquote><p> 项目中遇到过用户只可以在一端登录。登录成功后将会话信息存入redis并且返回前端（SET_COOKIE）;<br> 项目中加拦截器。比较请求携带的cookie和redis中的cookie是否一致。如果不一致，则在他出已经登录，反之，则通过。</p><blockquote><p>不同域下。</p></blockquote><p>只是确定一个公用的域，当访问的时候，倘若没有登录，则跳到登录服务器验证，返回token并保存。在跳转至访问地址。用凭证判断是否已经登录。<br>访问第二个域时。重定向到登录服务器校验是否已登陆，已登录则返回凭证供第二个服务使用。反之则登录。</p><img src="/2019/03/21/关于单点登录问题/001.jpg" title="cas">]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Fastdfs 文件配置 详解</title>
      <link href="/2019/01/16/Fastdfs-%E6%96%87%E4%BB%B6%E9%85%8D%E7%BD%AE-%E8%AF%A6%E8%A7%A3/"/>
      <url>/2019/01/16/Fastdfs-%E6%96%87%E4%BB%B6%E9%85%8D%E7%BD%AE-%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<pre><code>首先是 tracker.conf# is this config file disabled# false for enabled# true for disableddisabled=false# 这个配置文件是否不生效,呵呵(改成是否生效是不是会让人感觉好点呢?) false 为生效(否则不生效) true反之# bind an address of this host# empty for bind all addresses of this hostbind_addr=# 是否绑定IP,# bind_addr= 后面为绑定的IP地址 (常用于服务器有多个IP但只希望一个IP提供服务)。如果不填则表示所有的(一般不填就OK),相信较熟练的SA都常用到类似功能,很多系统和应用都有# the tracker server portport=22122# 提供服务的端口,不作过多解释了# connect timeout in seconds# default value is 30sconnect_timeout=30#连接超时时间，针对socket套接字函数connect# network timeout in secondsnetwork_timeout=60#  tracker server的网络超时，单位为秒。发送或接收数据时，如果在超时时间后还不能发送或接收数据，则本次网络通信失败。 # the base path to store data and log filesbase_path=/home/yuqing/fastdfs# base_path 目录地址(根目录必须存在,子目录会自动创建)# 附目录说明: tracker server目录及文件结构：${base_path}    |__data    |     |__storage_groups.dat：存储分组信息    |     |__storage_servers.dat：存储服务器列表    |__logs        |__trackerd.log：tracker server日志文件数据文件storage_groups.dat和storage_servers.dat中的记录之间以换行符（\n）分隔，字段之间以西文逗号（,）分隔。storage_groups.dat中的字段依次为：1. group_name：组名2. storage_port：storage server端口号storage_servers.dat中记录storage server相关信息，字段依次为：1. group_name：所属组名2. ip_addr：ip地址3. status：状态4. sync_src_ip_addr：向该storage server同步已有数据文件的源服务器5. sync_until_timestamp：同步已有数据文件的截至时间（UNIX时间戳）6. stat.total_upload_count：上传文件次数7. stat.success_upload_count：成功上传文件次数8. stat.total_set_meta_count：更改meta data次数9. stat.success_set_meta_count：成功更改meta data次数10. stat.total_delete_count：删除文件次数11. stat.success_delete_count：成功删除文件次数12. stat.total_download_count：下载文件次数13. stat.success_download_count：成功下载文件次数14. stat.total_get_meta_count：获取meta data次数15. stat.success_get_meta_count：成功获取meta data次数16. stat.last_source_update：最近一次源头更新时间（更新操作来自客户端）17. stat.last_sync_update：最近一次同步更新时间（更新操作来自其他storage server的同步）# max concurrent connections this server supported# max_connections worker threads start when this service startupmax_connections=256# 系统提供服务时的最大连接数。对于V1.x，因一个连接由一个线程服务，也就是工作线程数。# 对于V2.x，最大连接数和工作线程数没有任何关系# work thread count, should &lt;= max_connections# default value is 4# since V2.00# V2.0引入的这个参数，工作线程数，通常设置为CPU数work_threads=4# the method of selecting group to upload files# 0: round robin# 1: specify group# 2: load balance, select the max free space group to upload filestore_lookup=2# 上传组(卷) 的方式 0:轮询方式 1: 指定组 2: 平衡负载(选择最大剩余空间的组(卷)上传)# 这里如果在应用层指定了上传到一个固定组,那么这个参数被绕过# which group to upload file# when store_lookup set to 1, must set store_group to the group namestore_group=group2# 当上一个参数设定为1 时 (store_lookup=1，即指定组名时)，必须设置本参数为系统中存在的一个组名。如果选择其他的上传方式，这个参数就没有效了。# which storage server to upload file# 0: round robin (default)# 1: the first server order by ip address# 2: the first server order by priority (the minimal)store_server=0# 选择哪个storage server 进行上传操作(一个文件被上传后，这个storage server就相当于这个文件的storage server源，会对同组的storage server推送这个文件达到同步效果)# 0: 轮询方式 # 1: 根据ip 地址进行排序选择第一个服务器（IP地址最小者）# 2: 根据优先级进行排序（上传优先级由storage server来设置，参数名为upload_priority） # which path(means disk or mount point) of the storage server to upload file# 0: round robin# 2: load balance, select the max free space path to upload filestore_path=0# 选择storage server 中的哪个目录进行上传。storage server可以有多个存放文件的base path（可以理解为多个磁盘）。# 0: 轮流方式，多个目录依次存放文件# 2: 选择剩余空间最大的目录存放文件（注意：剩余磁盘空间是动态的，因此存储到的目录或磁盘可能也是变化的）# which storage server to download file# 0: round robin (default)# 1: the source storage server which the current file uploaded todownload_server=0# 选择哪个 storage server 作为下载服务器 # 0: 轮询方式，可以下载当前文件的任一storage server# 1: 哪个为源storage server 就用哪一个 (前面说过了这个storage server源 是怎样产生的) 就是之前上传到哪个storage server服务器就是哪个了# reserved storage space for system or other applications.# if the free(available) space of any stoarge server in# a group &lt;= reserved_storage_space,# no file can be uploaded to this group.# bytes unit can be one of follows:### G or g for gigabyte(GB)### M or m for megabyte(MB)### K or k for kilobyte(KB)### no unit for byte(B)### XX.XX% as ratio such as reserved_storage_space = 10%reserved_storage_space = 10%# storage server 上保留的空间，保证系统或其他应用需求空间。可以用绝对值或者百分比（V4开始支持百分比方式）。#(指出 如果同组的服务器的硬盘大小一样,以最小的为准,也就是只要同组中有一台服务器达到这个标准了,这个标准就生效,原因就是因为他们进行备份)#standard log level as syslog, case insensitive, value list:### emerg for emergency### alert### crit for critical### error### warn for warning### notice### info### debuglog_level=info# 选择日志级别(日志写在哪?看前面的说明了,有目录介绍哦 呵呵)#unix group name to run this program, #not set (empty) means run by the group of current userrun_by_group=# 操作系统运行FastDFS的用户组 (不填 就是当前用户组,哪个启动进程就是哪个)#unix username to run this program,#not set (empty) means run by current userrun_by_user=# 操作系统运行FastDFS的用户 (不填 就是当前用户,哪个启动进程就是哪个)# allow_hosts can ocur more than once, host can be hostname or ip address,# &quot;*&quot; means match all ip addresses, can use range like this: 10.0.1.[1-15,20] or# host[01-08,20-25].domain.com, for example:# allow_hosts=10.0.1.[1-15,20]# allow_hosts=host[01-08,20-25].domain.comallow_hosts=*# 可以连接到此 tracker server 的ip范围（对所有类型的连接都有影响，包括客户端，storage server）# sync log buff to disk every interval seconds# default value is 10 secondssync_log_buff_interval = 10# 同步或刷新日志信息到硬盘的时间间隔，单位为秒# 注意：tracker server 的日志不是时时写硬盘的，而是先写内存。# check storage server alive intervalcheck_active_interval = 120# 检测 storage server 存活的时间隔，单位为秒。# storage server定期向tracker server 发心跳，如果tracker server在一个check_active_interval内还没有收到storage server的一次心跳，那边将认为该storage server已经下线。所以本参数值必须大于storage server配置的心跳时间间隔。通常配置为storage server心跳时间间隔的2倍或3倍。# thread stack size, should &gt; 512KB# default value is 1MBthread_stack_size=1MB# 线程栈的大小。FastDFS server端采用了线程方式。更正一下，tracker server线程栈不应小于64KB，不是512KB。# 线程栈越大，一个线程占用的系统资源就越多。如果要启动更多的线程（V1.x对应的参数为max_connections，V2.0为work_threads），可以适当降低本参数值。# auto adjust when the ip address of the storage server changed# default value is truestorage_ip_changed_auto_adjust=true# 这个参数控制当storage server IP地址改变时，集群是否自动调整。注：只有在storage server进程重启时才完成自动调整。# storage sync file max delay seconds# default value is 86400 seconds (one day)# since V2.00storage_sync_file_max_delay = 86400# V2.0引入的参数。存储服务器之间同步文件的最大延迟时间，缺省为1天。根据实际情况进行调整# 注：本参数并不影响文件同步过程。本参数仅在下载文件时，判断文件是否已经被同步完成的一个阀值（经验值）# the max time of storage sync a file# default value is 300 seconds# since V2.00storage_sync_file_max_time = 300# V2.0引入的参数。存储服务器同步一个文件需要消耗的最大时间，缺省为300s，即5分钟。# 注：本参数并不影响文件同步过程。本参数仅在下载文件时，作为判断当前文件是否被同步完成的一个阀值（经验值）# if use a trunk file to store several small files# default value is false# since V3.00use_trunk_file = false# V3.0引入的参数。是否使用小文件合并存储特性，缺省是关闭的。# the min slot size, should &lt;= 4KB# default value is 256 bytes# since V3.00slot_min_size = 256# V3.0引入的参数。# trunk file分配的最小字节数。比如文件只有16个字节，系统也会分配slot_min_size个字节。# the max slot size, should &gt; slot_min_size# store the upload file to trunk file when it&apos;s size &lt;=  this value# default value is 16MB# since V3.00slot_max_size = 16MB# V3.0引入的参数。# 只有文件大小&lt;=这个参数值的文件，才会合并存储。如果一个文件的大小大于这个参数值，将直接保存到一个文件中（即不采用合并存储方式）。# the trunk file size, should &gt;= 4MB# default value is 64MB# since V3.00trunk_file_size = 64MB# V3.0引入的参数。# 合并存储的trunk file大小，至少4MB，缺省值是64MB。不建议设置得过大。# if create trunk file advancely# default value is falsetrunk_create_file_advance = false# 是否提前创建trunk file。只有当这个参数为true，下面3个以trunk_create_file_打头的参数才有效。# the time base to create trunk file# the time format: HH:MM# default value is 02:00trunk_create_file_time_base = 02:00# 提前创建trunk file的起始时间点（基准时间），02:00表示第一次创建的时间点是凌晨2点。# the interval of create trunk file, unit: second# default value is 38400 (one day)trunk_create_file_interval = 86400# 创建trunk file的时间间隔，单位为秒。如果每天只提前创建一次，则设置为86400# the threshold to create trunk file# when the free trunk file size less than the threshold, will create # the trunk files# default value is 0trunk_create_file_space_threshold = 20G# 提前创建trunk file时，需要达到的空闲trunk大小# 比如本参数为20G，而当前空闲trunk为4GB，那么只需要创建16GB的trunk file即可。# if check trunk space occupying when loading trunk free spaces# the occupied spaces will be ignored# default value is false# since V3.09# NOTICE: set this parameter to true will slow the loading of trunk spaces# when startup. you should set this parameter to true when neccessary.trunk_init_check_occupying = false#trunk初始化时，是否检查可用空间是否被占用# if ignore storage_trunk.dat, reload from trunk binlog# default value is false# since V3.10# set to true once for version upgrade when your version less than V3.10trunk_init_reload_from_binlog = false# 是否无条件从trunk binlog中加载trunk可用空间信息# FastDFS缺省是从快照文件storage_trunk.dat中加载trunk可用空间，# 该文件的第一行记录的是trunk binlog的offset，然后从binlog的offset开始加载# if use storage ID instead of IP address# default value is false# since V4.00use_storage_id = false# 是否使用server ID作为storage server标识# specify storage ids filename, can use relative or absolute path# since V4.00storage_ids_filename = storage_ids.conf# use_storage_id 设置为true，才需要设置本参数# 在文件中设置组名、server ID和对应的IP地址，参见源码目录下的配置示例：conf/storage_ids.conf# if store slave file use symbol link# default value is false# since V4.01store_slave_file_use_link = false# 存储从文件是否采用symbol link（符号链接）方式# 如果设置为true，一个从文件将占用两个文件：原始文件及指向它的符号链接。# if rotate the error log every day# default value is false# since V4.02rotate_error_log = false# 是否定期轮转error log，目前仅支持一天轮转一次# rotate error log time base, time format: Hour:Minute# Hour from 0 to 23, Minute from 0 to 59# default value is 00:00# since V4.02error_log_rotate_time=00:00# error log定期轮转的时间点，只有当rotate_error_log设置为true时有效# rotate error log when the log file exceeds this size# 0 means never rotates log file by log file size# default value is 0# since V4.02rotate_error_log_size = 0# error log按大小轮转# 设置为0表示不按文件大小轮转，否则当error log达到该大小，就会轮转到新文件中# 以下是关于http的设置了 默认编译是不生效的 要求更改 #WITH_HTTPD=1 将 注释#去掉 再编译# 关于http的应用 说实话 不是很了解 没有见到 相关说明 ,望 版主可以完善一下 以下是字面解释了#HTTP settingshttp.disabled=false   # HTTP服务是否不生效 http.server_port=8080  # HTTP服务端口#use &quot;#include&quot; directive to include http other settiongs##include http.conf  # 如果加载http.conf的配置文件 去掉第一个#哈哈 完成了一个 下面是 storage.conf# is this config file disabled# false for enabled# true for disableddisabled=false  #同上文了 就不多说了# the name of the group this storage server belongs togroup_name=group1# 指定 此 storage server 所在 组(卷)# bind an address of this host# empty for bind all addresses of this hostbind_addr=# 同上文# if bind an address of this host when connect to other servers # (this storage server as a client)# true for binding the address configed by above parameter: &quot;bind_addr&quot;# false for binding any address of this hostclient_bind=true# bind_addr通常是针对server的。当指定bind_addr时，本参数才有效。# 本storage server作为client连接其他服务器（如tracker server、其他storage server），是否绑定bind_addr。# the storage server portport=23000#  storage server服务端口# connect timeout in seconds# default value is 30sconnect_timeout=30#连接超时时间，针对socket套接字函数connect# network timeout in secondsnetwork_timeout=60#  storage server 网络超时时间，单位为秒。发送或接收数据时，如果在超时时间后还不能发送或接收数据，则本次网络通信失败。# heart beat interval in secondsheart_beat_interval=30# 心跳间隔时间，单位为秒 (这里是指主动向tracker server 发送心跳)# disk usage report interval in secondsstat_report_interval=60# storage server向tracker server报告磁盘剩余空间的时间间隔，单位为秒。# the base path to store data and log filesbase_path=/home/yuqing/fastdfs# base_path 目录地址,根目录必须存在  子目录会自动生成 (注 :这里不是上传的文件存放的地址,之前是的,在某个版本后更改了)# 目录结构 因为 版主没有更新到 论谈上 这里就不发了 大家可以看一下置顶贴:# max concurrent connections server supported# max_connections worker threads start when this service startupmax_connections=256# 同上文# work thread count, should &lt;= max_connections# default value is 4# since V2.00# V2.0引入的这个参数，工作线程数，通常设置为CPU数work_threads=4# the buff size to recv / send data# default value is 64KB# since V2.00buff_size = 256KB# V2.0引入本参数。设置队列结点的buffer大小。工作队列消耗的内存大小 = buff_size * max_connections# 设置得大一些，系统整体性能会有所提升。# 消耗的内存请不要超过系统物理内存大小。另外，对于32位系统，请注意使用到的内存不要超过3GB# if read / write file directly# if set to true, open file will add the O_DIRECT flag to avoid file caching# by the file system. be careful to set this parameter.# default value is falsedisk_rw_direct = false# V2.09引入本参数。设置为true，表示不使用操作系统的文件内容缓冲特性。# 如果文件数量很多，且访问很分散，可以考虑将本参数设置为true# if disk read / write separated##  false for mixed read and write##  true for separated read and write# default value is true# since V2.00disk_rw_separated = true# V2.0引入本参数。磁盘IO读写是否分离，缺省是分离的。# disk reader thread count per store base path# for mixed read / write, this parameter can be 0# default value is 1# since V2.00disk_reader_threads = 1# V2.0引入本参数。针对单个存储路径的读线程数，缺省值为1。# 读写分离时，系统中的读线程数 = disk_reader_threads * store_path_count# 读写混合时，系统中的读写线程数 = (disk_reader_threads + disk_writer_threads) * store_path_count# disk writer thread count per store base path# for mixed read / write, this parameter can be 0# default value is 1# since V2.00disk_writer_threads = 1# V2.0引入本参数。针对单个存储路径的写线程数，缺省值为1。# 读写分离时，系统中的写线程数 = disk_writer_threads * store_path_count# 读写混合时，系统中的读写线程数 = (disk_reader_threads + disk_writer_threads) * store_path_count# when no entry to sync, try read binlog again after X milliseconds# 0 for try again immediately (not need to wait)sync_wait_msec=200# 同步文件时，如果从binlog中没有读到要同步的文件，休眠N毫秒后重新读取。0表示不休眠，立即再次尝试读取。# 出于CPU消耗考虑，不建议设置为0。如何希望同步尽可能快一些，可以将本参数设置得小一些，比如设置为10ms# after sync a file, usleep milliseconds# 0 for sync successively (never call usleep)sync_interval=0# 同步上一个文件后，再同步下一个文件的时间间隔，单位为毫秒，0表示不休眠，直接同步下一个文件。 # sync start time of a day, time format: Hour:Minute# Hour from 0 to 23, Minute from 0 to 59sync_start_time=00:00# sync end time of a day, time format: Hour:Minute# Hour from 0 to 23, Minute from 0 to 59sync_end_time=23:59# 上面二个一起解释。允许系统同步的时间段 (默认是全天) 。一般用于避免高峰同步产生一些问题而设定，相信sa都会明白# write to the mark file after sync N files# default value is 500write_mark_file_freq=500# 同步完N个文件后，把storage的mark文件同步到磁盘# 注：如果mark文件内容没有变化，则不会同步# path(disk or mount point) count, default value is 1store_path_count=1# 存放文件时storage server支持多个路径（例如磁盘）。这里配置存放文件的基路径数目，通常只配一个目录。# store_path#, based 0, if store_path0 not exists, it&apos;s value is base_path# the paths must be existstore_path0=/home/yuqing/fastdfs#store_path1=/home/yuqing/fastdfs2# 逐一配置store_path个路径，索引号基于0。注意配置方法后面有0,1,2 ......，需要配置0到store_path - 1。# 如果不配置base_path0，那边它就和base_path对应的路径一样。# subdir_count  * subdir_count directories will be auto created under each # store_path (disk), value can be 1 to 256, default value is 256subdir_count_per_path=256# FastDFS存储文件时，采用了两级目录。这里配置存放文件的目录个数 (系统的存储机制,大家看看文件存储的目录就知道了)# 如果本参数只为N（如：256），那么storage server在初次运行时，会自动创建 N * N 个存放文件的子目录。# tracker_server can ocur more than once, and tracker_server format is#  &quot;host:port&quot;, host can be hostname or ip addresstracker_server=10.62.164.84:22122tracker_server=10.62.245.170:22122# tracker_server 的列表 要写端口的哦 (再次提醒是主动连接tracker_server )# 有多个tracker server时，每个tracker server写一行#standard log level as syslog, case insensitive, value list:### emerg for emergency### alert### crit for critical### error### warn for warning### notice### info### debuglog_level=info# 日志级别不多说#unix group name to run this program, #not set (empty) means run by the group of current userrun_by_group=# 同上文了#unix username to run this program,#not set (empty) means run by current userrun_by_user=# 同上文了 (提醒注意权限 如果和 webserver不搭 可以会产生错误 哦)# allow_hosts can ocur more than once, host can be hostname or ip address,# &quot;*&quot; means match all ip addresses, can use range like this: 10.0.1.[1-15,20] or# host[01-08,20-25].domain.com, for example:# allow_hosts=10.0.1.[1-15,20]# allow_hosts=host[01-08,20-25].domain.comallow_hosts=*# 允许连接本storage server的IP地址列表 （不包括自带HTTP服务的所有连接）# 可以配置多行，每行都会起作用# the mode of the files distributed to the data path # 0: round robin(default)# 1: random, distributted by hash codefile_distribute_path_mode=0#  文件在data目录下分散存储策略。# 0: 轮流存放，在一个目录下存储设置的文件数后（参数file_distribute_rotate_count中设置文件数），使用下一个目录进行存储。# 1: 随机存储，根据文件名对应的hash code来分散存储。# valid when file_distribute_to_path is set to 0 (round robin), # when the written file count reaches this number, then rotate to next path# default value is 100file_distribute_rotate_count=100   # 当上面的参数file_distribute_path_mode配置为0（轮流存放方式）时，本参数有效。# 当一个目录下的文件存放的文件数达到本参数值时，后续上传的文件存储到下一个目录中。# call fsync to disk when write big file# 0: never call fsync# other: call fsync when written bytes &gt;= this bytes# default value is 0 (never call fsync)fsync_after_written_bytes=0# 当写入大文件时，每写入N个字节，调用一次系统函数fsync将内容强行同步到硬盘。0表示从不调用fsync  # sync log buff to disk every interval seconds# default value is 10 secondssync_log_buff_interval=10# 同步或刷新日志信息到硬盘的时间间隔，单位为秒# 注意：storage server 的日志信息不是时时写硬盘的，而是先写内存。# sync binlog buff / cache to disk every interval seconds# this parameter is valid when write_to_binlog set to 1# default value is 60 secondssync_binlog_buff_interval=60# 同步binglog（更新操作日志）到硬盘的时间间隔，单位为秒# 本参数会影响新上传文件同步延迟时间# sync storage stat info to disk every interval seconds# default value is 300 secondssync_stat_file_interval=300# 把storage的stat文件同步到磁盘的时间间隔，单位为秒。# 注：如果stat文件内容没有变化，不会进行同步# thread stack size, should &gt;= 512KB# default value is 512KBthread_stack_size=512KB# 线程栈的大小。FastDFS server端采用了线程方式。# 对于V1.x，storage server线程栈不应小于512KB；对于V2.0，线程栈大于等于128KB即可。# 线程栈越大，一个线程占用的系统资源就越多。# 对于V1.x，如果要启动更多的线程（max_connections），可以适当降低本参数值。# the priority as a source server for uploading file.# the lower this value, the higher its uploading priority.# default value is 10upload_priority=10#  本storage server作为源服务器，上传文件的优先级，可以为负数。值越小，优先级越高。这里就和 tracker.conf 中store_server= 2时的配置相对应了 # if check file duplicate, when set to true, use FastDHT to store file indexes# 1 or yes: need check# 0 or no: do not check# default value is 0check_file_duplicate=0# 是否检测上传文件已经存在。如果已经存在，则不存在文件内容，建立一个符号链接以节省磁盘空间。 # 这个应用要配合FastDHT 使用，所以打开前要先安装FastDHT # 1或yes 是检测，0或no 是不检测# file signature method for check file duplicate## hash: four 32 bits hash code## md5: MD5 signature# default value is hash# since V4.01file_signature_method=hash# 文件去重时，文件内容的签名方式：## hash： 4个hash code## md5：MD5# namespace for storing file indexes (key-value pairs)# this item must be set when check_file_duplicate is true / onkey_namespace=FastDFS# 当上个参数设定为1 或 yes时 (true/on也是可以的) ， 在FastDHT中的命名空间。# set keep_alive to 1 to enable persistent connection with FastDHT servers# default value is 0 (short connection)keep_alive=0# 与FastDHT servers 的连接方式 (是否为持久连接) ，默认是0（短连接方式）。可以考虑使用长连接，这要看FastDHT server的连接数是否够用。# 下面是关于FastDHT servers 的设定 需要对FastDHT servers 有所了解,这里只说字面意思了# you can use &quot;#include filename&quot; (not include double quotes) directive to # load FastDHT server list, when the filename is a relative path such as # pure filename, the base path is the base path of current/this config file.# must set FastDHT server list when check_file_duplicate is true / on# please see INSTALL of FastDHT for detail##include /home/yuqing/fastdht/conf/fdht_servers.conf# 可以通过 #include filename 方式来加载 FastDHT servers  的配置，装上FastDHT就知道该如何配置啦。# 同样要求 check_file_duplicate=1 时才有用，不然系统会忽略# fdht_servers.conf 记载的是 FastDHT servers 列表 # if log to access log# default value is false# since V4.00use_access_log = false# 是否将文件操作记录到access log# if rotate the access log every day# default value is false# since V4.00rotate_access_log = false# 是否定期轮转access log，目前仅支持一天轮转一次# rotate access log time base, time format: Hour:Minute# Hour from 0 to 23, Minute from 0 to 59# default value is 00:00# since V4.00access_log_rotate_time=00:00# access log定期轮转的时间点，只有当rotate_access_log设置为true时有效# if rotate the error log every day# default value is false# since V4.02rotate_error_log = false# 是否定期轮转error log，目前仅支持一天轮转一次# rotate error log time base, time format: Hour:Minute# Hour from 0 to 23, Minute from 0 to 59# default value is 00:00# since V4.02error_log_rotate_time=00:00# error log定期轮转的时间点，只有当rotate_error_log设置为true时有效# rotate access log when the log file exceeds this size# 0 means never rotates log file by log file size# default value is 0# since V4.02rotate_access_log_size = 0# access log按文件大小轮转# 设置为0表示不按文件大小轮转，否则当access log达到该大小，就会轮转到新文件中# rotate error log when the log file exceeds this size# 0 means never rotates log file by log file size# default value is 0# since V4.02rotate_error_log_size = 0# error log按文件大小轮转# 设置为0表示不按文件大小轮转，否则当error log达到该大小，就会轮转到新文件中# if skip the invalid record when sync file# default value is false# since V4.02file_sync_skip_invalid_record=false# 文件同步的时候，是否忽略无效的binlog记录下面是http的配置了。如果系统较大，这个服务有可能支持不了，可以自行换一个webserver，我喜欢lighttpd，当然ng也很好了。具体不说明了。相应这一块的说明大家都懂，不明白见上文。#HTTP settingshttp.disabled=false# the port of the web server on this storage serverhttp.server_port=8888http.trunk_size=256KB# http.trunk_size表示读取文件内容的buffer大小（一次读取的文件内容大小），也就是回复给HTTP client的块大小。# use the ip address of this storage server if domain_name is empty,# else this domain name will ocur in the url redirected by the tracker serverhttp.domain_name=# storage server上web server域名，通常仅针对单独部署的web server。这样URL中就可以通过域名方式来访问storage server上的文件了，# 这个参数为空就是IP地址的方式。#use &quot;#include&quot; directive to include HTTP other settiongs##include http.conf</code></pre>]]></content>
      
      
      <categories>
          
          <category> CentOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CentOS 服务搭建 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Test 外网是否被墙</title>
      <link href="/2018/11/06/Test-%E5%A4%96%E7%BD%91%E6%98%AF%E5%90%A6%E8%A2%AB%E5%A2%99/"/>
      <url>/2018/11/06/Test-%E5%A4%96%E7%BD%91%E6%98%AF%E5%90%A6%E8%A2%AB%E5%A2%99/</url>
      
        <content type="html"><![CDATA[<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=27580343&auto=1&height=66"></iframe><blockquote><p>本篇用于测试外网Ip是否被墙。</p></blockquote><h4 id="1-全国-Ping-测试网页-https-www-ipip-net-ping-php"><a href="#1-全国-Ping-测试网页-https-www-ipip-net-ping-php" class="headerlink" title="1. 全国 Ping 测试网页(https://www.ipip.net/ping.php)"></a>1. 全国 Ping 测试网页(<a href="https://www.ipip.net/ping.php" target="_blank" rel="noopener">https://www.ipip.net/ping.php</a>)</h4><p>如下图，输入ip之后点击ping，如果丢包率 100%，那肯定是被 Q 了，这种情况只能删除机器重建了。反之，那也不一定说明没有被 Q，接下来用下面两步继续检测。<br><img src="/2018/11/06/Test-外网是否被墙/001.png" title="ping测试"></p><h4 id="2-国内外端口扫描测试-http-tool-chinaz-com-port"><a href="#2-国内外端口扫描测试-http-tool-chinaz-com-port" class="headerlink" title="2. 国内外端口扫描测试(http://tool.chinaz.com/port)"></a>2. 国内外端口扫描测试(<a href="http://tool.chinaz.com/port" target="_blank" rel="noopener">http://tool.chinaz.com/port</a>)</h4><p>如果出现下面情况，说明在国内该 IP 已经被封掉了，试试下一步去国外检测端口是否可用。<br><img src="/2018/11/06/Test-外网是否被墙/002.png" title="ping测试"><br>如果出现下面情况，说明国内并没有封掉该 IP。<br><img src="/2018/11/06/Test-外网是否被墙/003.png" title="ping测试"></p><h4 id="3-国外测试-https-www-yougetsignal-com-tools-open-ports"><a href="#3-国外测试-https-www-yougetsignal-com-tools-open-ports" class="headerlink" title="3. 国外测试(https://www.yougetsignal.com/tools/open-ports/)"></a>3. 国外测试(<a href="https://www.yougetsignal.com/tools/open-ports/" target="_blank" rel="noopener">https://www.yougetsignal.com/tools/open-ports/</a>)</h4><img src="/2018/11/06/Test-外网是否被墙/004.png" title="ping测试"><ul><li>如果上一步 22 端口是关闭状态，在这边检测是 open 状态，说明 IP 肯定是被封掉了，只能删除机器重建。</li><li>如果上一步 22 店口是关闭状态，这边检测也是 close 状态，那就要查看是不是服务器的防火墙把端口限制了。</li></ul>]]></content>
      
      
      <categories>
          
          <category> CentOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CentOS 服务搭建 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vultr 搭建 VPS 外网ssr服务器</title>
      <link href="/2018/11/06/Vultr-%E6%90%AD%E5%BB%BA-VPS%E5%A4%96%E7%BD%91%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
      <url>/2018/11/06/Vultr-%E6%90%AD%E5%BB%BA-VPS%E5%A4%96%E7%BD%91%E6%9C%8D%E5%8A%A1%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=25714146&auto=1&height=66"></iframe><blockquote><p>搭建自己的shadowsocks代理服务器实现科学上网。内容包括VPS购买，连接VPS，一键搭建shadowsocks，开启bbr加速，客户端配置shaodowsocks。</p></blockquote><h4 id="1-购买VPS"><a href="#1-购买VPS" class="headerlink" title="1. 购买VPS"></a>1. 购买VPS</h4><p>VPS（Virtual private server，虚拟专用服务器），个人用来搭建一些博客，跑跑脚本足够了。今天的教程就用VPS来搭建属于自己的shaodowsocks，一个人独占一条线路。</p><p>Vultr是美国的一个VPS服务商。</p><h5 id="1-1-新用户注册"><a href="#1-1-新用户注册" class="headerlink" title="1.1 新用户注册"></a>1.1 新用户注册</h5><p>优惠注册链接：<a href="http://www.vultr.com" target="_blank" rel="noopener">www.vultr.com</a><br><img src="/2018/11/06/Vultr-搭建-VPS外网服务器/001.png" title="注册"></p><h5 id="1-2-充值。"><a href="#1-2-充值。" class="headerlink" title="1.2 充值。"></a>1.2 充值。</h5><p>因为Vultr是按小时收费的。先充值才可以用。<br>验证并登录后我们会跳转到充值界面，或者从Billing-&gt;Make Patment进入：<br><img src="/2018/11/06/Vultr-搭建-VPS外网服务器/002.png" title="充值"></p><p>支持支付宝，微信等，很方便，充值10刀，按小时扣费，只要保证账户有余额，你的服务器就会一直运行。</p><h5 id="1-3-购买服务器"><a href="#1-3-购买服务器" class="headerlink" title="1.3 购买服务器"></a>1.3 购买服务器</h5><img src="/2018/11/06/Vultr-搭建-VPS外网服务器/003.png" title="购买服务器"><p>由于2.5刀的没有ipv4。所以我直接购买的3.5刀每月的。<br><img src="/2018/11/06/Vultr-搭建-VPS外网服务器/004.png" title="购买服务器选择"><br>点击开启ipv6。然后Deploy Now 就可以了。<br><img src="/2018/11/06/Vultr-搭建-VPS外网服务器/005.png" title="购买服务器"></p><h5 id="1-4-获取VPS登录信息"><a href="#1-4-获取VPS登录信息" class="headerlink" title="1.4 获取VPS登录信息"></a>1.4 获取VPS登录信息</h5><p>选择Deploy后，过个几分钟，就可以看到自己的服务器信息了，具体位置在Servers-&gt;Instances，点击选择你新建的实例：</p><img src="/2018/11/06/Vultr-搭建-VPS外网服务器/006.png" title="获取登录信息"><h4 id="2-连接VPS"><a href="#2-连接VPS" class="headerlink" title="2. 连接VPS"></a>2. 连接VPS</h4><p>这时候开始连接我们的VPS。</p><h5 id="2-1-开启防火墙端口"><a href="#2-1-开启防火墙端口" class="headerlink" title="2.1 开启防火墙端口"></a>2.1 开启防火墙端口</h5><p>这个和咱们国内的云服务器差不多。<br>点击菜单  Servers &gt;&gt; Firewall &gt;&gt; Add Firewall Group &gt;&gt; 输入描述 &gt;&gt; 编辑ipv4 规则。 &gt;&gt; Linked Instances &gt;&gt; 选择我们新建的vps。</p><img src="/2018/11/06/Vultr-搭建-VPS外网服务器/007.png" title="防火墙信息"><h5 id="2-2-测试是否被墙。"><a href="#2-2-测试是否被墙。" class="headerlink" title="2.2 测试是否被墙。"></a>2.2 测试是否被墙。</h5><p>站内地址：<a href="/2018/11/06/Test-外网是否被墙/" title="Test 外网是否被墙">Test 外网是否被墙</a></p><h5 id="2-3-Windows-Xshell-连接。"><a href="#2-3-Windows-Xshell-连接。" class="headerlink" title="2.3 Windows Xshell 连接。"></a>2.3 Windows Xshell 连接。</h5><p>在Servers Information 中。有ip 和 账号信息。直接连接就可以。</p><h4 id="3-一键搭建shaodowsocks"><a href="#3-一键搭建shaodowsocks" class="headerlink" title="3. 一键搭建shaodowsocks"></a>3. 一键搭建shaodowsocks</h4><h5 id="3-1-下载一键搭建ss脚本文件（直接复制这段代码运行即可）"><a href="#3-1-下载一键搭建ss脚本文件（直接复制这段代码运行即可）" class="headerlink" title="3.1 下载一键搭建ss脚本文件（直接复制这段代码运行即可）"></a>3.1 下载一键搭建ss脚本文件（直接复制这段代码运行即可）</h5><pre><code>git clone https://github.com/YangXHero/flyzy2005-ss-fly.git</code></pre><img src="/2018/11/06/Vultr-搭建-VPS外网服务器/009.png" title="下载git代码"><p>如果提示 <code>bash: git: command not found</code>，则先安装git：<code>yum install git -y</code></p><h5 id="3-2-运行搭建ssr脚本代码"><a href="#3-2-运行搭建ssr脚本代码" class="headerlink" title="3.2 运行搭建ssr脚本代码"></a>3.2 运行搭建ssr脚本代码</h5><p>听说ssr是改进版本，可以伪装成自定义的http开头，让监控着认为你是在访问百度，将实际的内容进行加密。SS是纯加密流量。所以直接搭建ssr。</p><pre><code>ss-fly/ss-fly.sh -i flyzy2005.com 1024</code></pre><h5 id="3-3-输入对应的参数"><a href="#3-3-输入对应的参数" class="headerlink" title="3.3 输入对应的参数"></a>3.3 输入对应的参数</h5><pre><code>密码：flyzy2005.com端口：1024</code></pre><p>全部选择结束后，会看到如下界面，就说明搭建ssr成功了：</p><pre><code>Congratulations, ShadowsocksR server install completed!Your Server IP        :你的服务器ipYour Server Port      :你的端口Your Password         :你的密码Your Protocol         :你的协议</code></pre><h5 id="3-4-相关操作命令"><a href="#3-4-相关操作命令" class="headerlink" title="3.4 相关操作命令"></a>3.4 相关操作命令</h5><pre><code>修改配置文件：vim /etc/shadowsocks.json停止ss服务：ssserver -c /etc/shadowsocks.json -d stop启动ss服务：ssserver -c /etc/shadowsocks.json -d start重启ss服务：ssserver -c /etc/shadowsocks.json -d restart</code></pre><h5 id="3-5-卸载"><a href="#3-5-卸载" class="headerlink" title="3.5 卸载"></a>3.5 卸载</h5><pre><code>ss-fly/ss-fly.sh -uninstall</code></pre><h4 id="4-一键开启BBR加速"><a href="#4-一键开启BBR加速" class="headerlink" title="4. 一键开启BBR加速"></a>4. 一键开启BBR加速</h4><p>BBR是Google开源的一套内核加速算法，可以让你搭建的shadowsocks/shadowsocksR速度上一个台阶，本一键搭建ss/ssr脚本支持一键升级最新版本的内核并开启BBR加速。</p><p>BBR支持4.9以上的，如果低于这个版本则会自动下载最新内容版本的内核后开启BBR加速并重启，如果高于4.9以上则自动开启BBR加速，执行如下脚本命令即可自动开启BBR加速：</p><pre><code>ss-fly/ss-fly.sh -bbr</code></pre><img src="/2018/11/06/Vultr-搭建-VPS外网服务器/010.png" title="bbr安装成功"><h5 id="4-1-判断bbr加速是否成功"><a href="#4-1-判断bbr加速是否成功" class="headerlink" title="4.1 判断bbr加速是否成功"></a>4.1 判断bbr加速是否成功</h5><p>判断BBR加速有没有开启成功。输入以下命令：</p><pre><code>sysctl net.ipv4.tcp_available_congestion_control</code></pre><p>如果返回值为：</p><pre><code>net.ipv4.tcp_available_congestion_control = bbr cubic reno</code></pre><p>后面有bbr，则说明已经开启成功了。</p><h4 id="5-启动"><a href="#5-启动" class="headerlink" title="5. 启动"></a>5. 启动</h4><ul><li>有两种启动方式，建议使用配置文件的方式启动</li></ul><p>执行<code>vim /etc/shadowsocks.json</code> 添加如下内容：</p><p>多用户配置如下：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#123;  </span><br><span class="line"> "server":"0.0.0.0"，  </span><br><span class="line"> "local_address": "127.0.0.1",  </span><br><span class="line"> "local_port":1080,  </span><br><span class="line">  "port_password": &#123;  </span><br><span class="line">     "8388": "password",  </span><br><span class="line">     "8387": "password",  </span><br><span class="line">     "8386": "password",  </span><br><span class="line">     "8385": "password"  </span><br><span class="line"> &#125;,  </span><br><span class="line"> "timeout":300,  </span><br><span class="line"> "method":"rc4-md5",  </span><br><span class="line"> "fast_open": false  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>然后通过执行一下命令启动：</p><pre><code>ssserver -c /etc/shadowsocks.json -d start如果要停止运行，将命令中的start改成stop。</code></pre><p>TIPS: 加密方式推荐使用rc4-md5，因为 RC4 比 AES 速度快好几倍，如果用在路由器上会带来显著性能提升。旧的 RC4 加密之所以不安全是因为 Shadowsocks 在每个连接上重复使用 key，没有使用 IV。现在已经重新正确实现，可以放心使用。更多可以看 issue。</p><h4 id="6-开机自启"><a href="#6-开机自启" class="headerlink" title="6.开机自启"></a>6.开机自启</h4><p>编辑一下/etc/supervisord.conf文件，命令如下：<br><code>vim /etc/supervisord.conf</code></p><p>把下面的内容粘贴到文件尾部的空行处，然后保存：</p><pre><code>[program:shadowsocks]command=ssserver -c /etc/shadowsocks.jsonautostart=trueautorestart=trueuser=rootlog_stderr=truelogfile=/var/log/shadowsocks.log</code></pre><p>接下来需要编辑一下/etc/rc.local文件，请执行以下命令：</p><pre><code>vi /etc/rc.local</code></pre><p>请把以下内容粘贴到文件中部的空白处，然后保存</p><pre><code>service supervisord start</code></pre><p>完成以上步骤后，重启之后，shadowsock会自动运行。</p>]]></content>
      
      
      <categories>
          
          <category> CentOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CentOS 服务搭建 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis集群搭建</title>
      <link href="/2018/10/26/Redis%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA/"/>
      <url>/2018/10/26/Redis%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA/</url>
      
        <content type="html"><![CDATA[<h4 id="1-安装搭建集群所需要的环境。"><a href="#1-安装搭建集群所需要的环境。" class="headerlink" title="1. 安装搭建集群所需要的环境。"></a>1. 安装搭建集群所需要的环境。</h4><pre><code>命令行运行：     yum -y install gcc psmisc</code></pre><h4 id="2-下载redis-安装文件-并解压。"><a href="#2-下载redis-安装文件-并解压。" class="headerlink" title="2. 下载redis 安装文件 并解压。"></a>2. 下载redis 安装文件 并解压。</h4><pre><code>wget http://download.redis.io/releases/redis-4.0.1.tar.gztar -zxvf 文件名。</code></pre><h4 id="3-进入解压好的文件目录，安装。"><a href="#3-进入解压好的文件目录，安装。" class="headerlink" title="3. 进入解压好的文件目录，安装。"></a>3. 进入解压好的文件目录，安装。</h4><pre><code>make MALLOC=libcmake &amp; make install</code></pre><ul><li>如果运行make报错，可能如下：</li><li>gcc依赖：yum install gcc gcc-c++ ncurses-devel</li><li>cd deps下。执行。  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">make hiredis</span><br><span class="line">make jemalloc</span><br><span class="line">make lua</span><br><span class="line">make linenoise</span><br></pre></td></tr></table></figure></li></ul><h4 id="4-搭建集群-—-创建集群所需目录"><a href="#4-搭建集群-—-创建集群所需目录" class="headerlink" title="4. 搭建集群 — 创建集群所需目录"></a>4. 搭建集群 — 创建集群所需目录</h4><pre><code>cd /usr/localmkdir redis-clustercd redis-clustermkdir 7001 7002 7003 7004 7005 7006</code></pre><h4 id="5-搭建集群-—-修改配置文件"><a href="#5-搭建集群-—-修改配置文件" class="headerlink" title="5. 搭建集群 — 修改配置文件"></a>5. 搭建集群 — 修改配置文件</h4><pre><code>cp /usr/local/redis-4.0.1/redis.conf 7001/vim 7001/redis.conf修改配置文件的选项如下    port 7001    daemonize yes    bind 127.0.0.1 注释掉    protected-mode yes  改为  no    如果yes 不允许外网访问。    pidfile  /var/run/redis_7001.pid    cluster-enabled yes    cluster-config-file nodes-7001.conf    cluster-node-timeout  15000               //请求超时  默认15秒，可自行设置    appendonly  yes如果要加密码的话：    masterauth 你的密码    requirepass 你的密码修改完成一个之后，复制7001下的文件到其他五个文件夹。    cp 7001/redis.conf 7002/    cp 7001/redis.conf 7003/    cp 7001/redis.conf 7004/    cp 7001/redis.conf 7005/    cp 7001/redis.conf 7006/然后全文搜索修改端口号就行。    vim 7002/redis.conf    :%s/7001/7002/g    改五次。</code></pre><h4 id="6-搭建集群-—-安装集群所需的依赖环境。"><a href="#6-搭建集群-—-安装集群所需的依赖环境。" class="headerlink" title="6. 搭建集群 — 安装集群所需的依赖环境。"></a>6. 搭建集群 — 安装集群所需的依赖环境。</h4><pre><code>yum -y install ruby rubygemsgem install redis如果提示： redis requires Ruby version &gt;= 2.2.2.CentOS7 yum库中ruby的版本支持到 2.0.0,可gem 安装redis需要最低是2.2.2,自己编译的ruby源码。解决方法如下：    yum -y install curl    curl -L get.rvm.io | bash -s stable    find / -name rvm -print    source /usr/local/rvm/scripts/rvm    rvm list known    rvm install 2.4.1    rvm use 2.4.1    rvm use 2.4.1 --default    rvm remove 2.0.0    ruby --version如果不成功，百度搜升级ruby。    gem install redis</code></pre><h4 id="7-如果加了密码，修改client-rb文件。"><a href="#7-如果加了密码，修改client-rb文件。" class="headerlink" title="7. 如果加了密码，修改client.rb文件。"></a>7. 如果加了密码，修改client.rb文件。</h4><pre><code>find / -name client.rb找到路径中包含redis版本号那个。vim 文件。</code></pre><img src="/2018/10/26/Redis集群搭建/001.png" title="修改连接密码"><h4 id="8-批处理文件启动redis。"><a href="#8-批处理文件启动redis。" class="headerlink" title="8. 批处理文件启动redis。"></a>8. 批处理文件启动redis。</h4><pre><code>vim redis-start.sh</code></pre><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">cd /usr/local/redis-cluster/7001/</span><br><span class="line">redis-server redis.conf</span><br><span class="line">cd /usr/local/redis-cluster/7002/</span><br><span class="line">redis-server redis.conf</span><br><span class="line">cd /usr/local/redis-cluster/7003/</span><br><span class="line">redis-server redis.conf</span><br><span class="line">cd /usr/local/redis-cluster/7004/</span><br><span class="line">redis-server redis.conf</span><br><span class="line">cd /usr/local/redis-cluster/7005/</span><br><span class="line">redis-server redis.conf</span><br><span class="line">cd /usr/local/redis-cluster/7006/</span><br><span class="line">redis-server redis.conf</span><br></pre></td></tr></table></figure><pre><code>chmod +x redis-start.shvim redis-remove.sh</code></pre><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">cd /usr/local/redis-cluster/7001/</span><br><span class="line">rm -rf appendonly.aof</span><br><span class="line">rm -rf nodes-7001.conf</span><br><span class="line">cd /usr/local/redis-cluster/7002/</span><br><span class="line">rm -rf appendonly.aof</span><br><span class="line">rm -rf nodes-7002.conf</span><br><span class="line">cd /usr/local/redis-cluster/7003/</span><br><span class="line">rm -rf appendonly.aof</span><br><span class="line">rm -rf nodes-7003.conf</span><br><span class="line">cd /usr/local/redis-cluster/7004/</span><br><span class="line">rm -rf appendonly.aof</span><br><span class="line">rm -rf nodes-7004.conf</span><br><span class="line">cd /usr/local/redis-cluster/7005/</span><br><span class="line">rm -rf appendonly.aof</span><br><span class="line">rm -rf nodes-7005.conf</span><br><span class="line">cd /usr/local/redis-cluster/7006/</span><br><span class="line">rm -rf appendonly.aof</span><br><span class="line">rm -rf nodes-7006.conf</span><br></pre></td></tr></table></figure><pre><code>chmod +x redis-remove.sh</code></pre><h4 id="9-集群搭建，启动集群"><a href="#9-集群搭建，启动集群" class="headerlink" title="9. 集群搭建，启动集群"></a>9. 集群搭建，启动集群</h4><pre><code>./redis-start.sh如果是云服务器，先放开端口 7001-7006  和 17001-17006./redis-trib.rb create --replicas 1 127.0.0.1:7001 127.0.0.1:7002 127.0.0.1:7003 127.0.0.1:7004 127.0.0.1:7005 127.0.0.1:7006将127.0.0.1 改成你的ip</code></pre>]]></content>
      
      
      <categories>
          
          <category> 安装教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Thread JDK1.5</title>
      <link href="/2018/10/24/Thread/"/>
      <url>/2018/10/24/Thread/</url>
      
        <content type="html"><![CDATA[<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=25862794&auto=1&height=66"></iframe><h3 id="一、Java5-前时代"><a href="#一、Java5-前时代" class="headerlink" title="一、Java5 前时代"></a>一、Java5 前时代</h3><h4 id="1-并发实现（两种）"><a href="#1-并发实现（两种）" class="headerlink" title="1. 并发实现（两种）"></a>1. 并发实现（两种）</h4><blockquote><p>Java Green Thread (模拟线程实现方式。)</p></blockquote><blockquote><p>Java Native Thread</p></blockquote><h4 id="2-局限性"><a href="#2-局限性" class="headerlink" title="2. 局限性"></a>2. 局限性</h4><pre><code>缺少线程管理的支持。（线程池）缺少“锁”API。缺少执行完成的状态。执行结果获取困难。Double Check locking 不确定性。</code></pre><h4 id="3-Code-例子"><a href="#3-Code-例子" class="headerlink" title="3. Code 例子"></a>3. Code 例子</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadMain</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * synchronized 关键字是是一种编程语言修饰符。</span></span><br><span class="line"><span class="comment">             * */</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.printf(<span class="string">"[Thread : %s] Hello , World... \n"</span>,Thread.currentThread().getName());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">"Sub"</span>);</span><br><span class="line"></span><br><span class="line">        thread.start();</span><br><span class="line">        System.out.printf(<span class="string">"[Thread : %s] Starting......\n"</span>,Thread.currentThread().getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 可完成的&#123;<span class="doctag">@link</span> Runnable&#125;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Yangkai</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2018-10-24-12:11</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CompletableRunnableMain</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        CompletableRunnable completableRunnable = <span class="keyword">new</span> CompletableRunnable();</span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread(completableRunnable, <span class="string">"Sub"</span>);</span><br><span class="line"></span><br><span class="line">        thread.start();</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Waits for this thread to die.</span></span><br><span class="line"><span class="comment">         * 等着线程执行结束。串行操作。</span></span><br><span class="line"><span class="comment">         **/</span></span><br><span class="line">        thread.join();</span><br><span class="line">        System.out.printf(<span class="string">"[Thread : %s] Starting......\n"</span>, Thread.currentThread().getName());</span><br><span class="line"></span><br><span class="line">        System.out.printf(<span class="string">"running is completed .....: %s\n"</span>, completableRunnable.isCompleted());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">CompletableRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> completed = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.printf(<span class="string">"[Thread : %s] Hello , World... \n"</span>, Thread.currentThread().getName());</span><br><span class="line">            completed = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isCompleted</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> completed;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Thread </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mysql57 rpm 安装</title>
      <link href="/2018/10/22/Mysql57-rpm-%E5%AE%89%E8%A3%85/"/>
      <url>/2018/10/22/Mysql57-rpm-%E5%AE%89%E8%A3%85/</url>
      
        <content type="html"><![CDATA[<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=546279760&auto=1&height=66"></iframe><h4 id="1-下载和安装mysql源"><a href="#1-下载和安装mysql源" class="headerlink" title="1.下载和安装mysql源"></a>1.下载和安装mysql源</h4><p>先下载 mysql源安装包<br>wget <a href="https://dev.mysql.com/get/mysql57-community-release-el7-11.noarch.rpm" target="_blank" rel="noopener">https://dev.mysql.com/get/mysql57-community-release-el7-11.noarch.rpm</a><br>-bash: wget: 未找到命令<br>我们先安装下wget<br>yum -y install wget<br>然后执行 wget <a href="https://dev.mysql.com/get/mysql57-community-release-el7-11.noarch.rpm" target="_blank" rel="noopener">https://dev.mysql.com/get/mysql57-community-release-el7-11.noarch.rpm</a></p><p>安装本地mysql源<br>yum -y localinstall mysql57-community-release-el7-11.noarch.rpm</p><h4 id="2-在线安装Mysql"><a href="#2-在线安装Mysql" class="headerlink" title="2.在线安装Mysql"></a>2.在线安装Mysql</h4><p>yum -y install mysql-community-server<br>下载的东西比较多 要稍微等会；</p><h4 id="3-启动Mysql服务"><a href="#3-启动Mysql服务" class="headerlink" title="3.启动Mysql服务"></a>3.启动Mysql服务</h4><p>systemctl start mysqld</p><h4 id="4-设置开机启动"><a href="#4-设置开机启动" class="headerlink" title="4.设置开机启动"></a>4.设置开机启动</h4><p>systemctl enable mysqld<br>systemctl daemon-reload</p><h4 id="5-修改root本地登录密码"><a href="#5-修改root本地登录密码" class="headerlink" title="5.修改root本地登录密码"></a>5.修改root本地登录密码</h4><p>mysql安装完成之后，在/var/log/mysqld.log文件中给root生成了一个临时的默认密码。<br>vi /var/log/mysqld.log<br><img src="/2018/10/22/Mysql57-rpm-安装/001.png" title="找临时密码"><br>[root@localhost ~]#  mysql -u root -p<br>Enter password:<br>输入临时密码 进入mysql命令行；</p><h4 id="6-修改密码。"><a href="#6-修改密码。" class="headerlink" title="6.修改密码。"></a>6.修改密码。</h4><p>首先，修改validate_password_policy参数的值<br>mysql&gt; set global validate_password_policy=0;<br>再修改密码的长度<br>mysql&gt; set global validate_password_length=1;<br>mysql&gt; ALTER USER ‘root‘@’localhost’ IDENTIFIED BY ‘<strong>**</strong>‘;  自定义密码。<br>Query OK, 0 rows affected (0    .00 sec)</p><h4 id="7-设置允许远程登录"><a href="#7-设置允许远程登录" class="headerlink" title="7.设置允许远程登录"></a>7.设置允许远程登录</h4><p>Mysql默认不允许远程登录，我们需要设置下，并且防火墙开放3306端口；<br>mysql&gt; GRANT ALL PRIVILEGES ON <em>.</em> TO ‘root‘@’%’ IDENTIFIED BY ‘yzyjy123’ WITH GRANT OPTION;<br>Query OK, 0 rows affected, 1 warning (0.01 sec)<br>mysql&gt; exit;</p><p>flush privileges</p><h4 id="8-Mysql57-需要修改sql-mode。"><a href="#8-Mysql57-需要修改sql-mode。" class="headerlink" title="8.Mysql57 需要修改sql_mode。"></a>8.Mysql57 需要修改sql_mode。</h4><pre><code>vi /etc/my.cnf在[mysqld]下面添加如下列：sql_mode=STRICT_TRANS_TABLES,ERROR_FOR_DIVISION_BY_ZERO,NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION</code></pre><h4 id="9-重新启动MySQL。"><a href="#9-重新启动MySQL。" class="headerlink" title="9.重新启动MySQL。"></a>9.重新启动MySQL。</h4><p>systemctl restart mysqld</p>]]></content>
      
      
      <categories>
          
          <category> CentOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CentOS 服务搭建 </tag>
            
            <tag> Mysql57 搭建。 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Nginx 专题</title>
      <link href="/2018/08/20/Nginx-%E5%AD%A6%E4%B9%A0/"/>
      <url>/2018/08/20/Nginx-%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=543607345&auto=1&height=66"></iframe><h4 id="Nginx安装"><a href="#Nginx安装" class="headerlink" title="Nginx安装"></a>Nginx安装</h4><h5 id="安装依赖"><a href="#安装依赖" class="headerlink" title="安装依赖"></a>安装依赖</h5><h6 id="gcc-安装"><a href="#gcc-安装" class="headerlink" title="gcc 安装"></a>gcc 安装</h6><p>安装 nginx 需要先将官网下载的源码进行编译，编译依赖 gcc 环境，如果没有 gcc 环境，则需要安装：</p><pre><code>yum install -y gcc-c++</code></pre><h6 id="PCRE-pcre-devel-安装"><a href="#PCRE-pcre-devel-安装" class="headerlink" title="PCRE pcre-devel 安装"></a>PCRE pcre-devel 安装</h6><p>PCRE(Perl Compatible Regular Expressions) 是一个Perl库，包括 perl 兼容的正则表达式库。nginx 的 http 模块使用 pcre 来解析正则表达式，所以需要在 linux 上安装 pcre 库，pcre-devel 是使用 pcre 开发的一个二次开发库。nginx也需要此库。命令：</p><pre><code>yum install -y pcre pcre-devel</code></pre><h6 id="zlib-安装"><a href="#zlib-安装" class="headerlink" title="zlib 安装"></a>zlib 安装</h6><p>zlib 库提供了很多种压缩和解压缩的方式， nginx 使用 zlib 对 http 包的内容进行 gzip ，所以需要在 Centos 上安装 zlib 库。</p><pre><code>yum install -y zlib zlib-devel</code></pre><h6 id="OpenSSL-安装"><a href="#OpenSSL-安装" class="headerlink" title="OpenSSL 安装"></a>OpenSSL 安装</h6><p>OpenSSL 是一个强大的安全套接字层密码库，囊括主要的密码算法、常用的密钥和证书封装管理功能及 SSL 协议，并提供丰富的应用程序供测试或其它目的使用。<br>nginx 不仅支持 http 协议，还支持 https（即在ssl协议上传输http），所以需要在 Centos 安装 OpenSSL 库。</p><pre><code>yum install -y openssl openssl-devel</code></pre><h5 id="安装nginx"><a href="#安装nginx" class="headerlink" title="安装nginx"></a>安装nginx</h5><h6 id="下载nginx"><a href="#下载nginx" class="headerlink" title="下载nginx"></a>下载nginx</h6><pre><code>wget https://nginx.org/download/nginx-1.12.1.tar.gz</code></pre><h6 id="编译安装"><a href="#编译安装" class="headerlink" title="编译安装"></a>编译安装</h6><pre><code>tar -zxvf nginx-1.12.1.tar.gzcd nginx-1.12.1./configuremakemake install</code></pre><h6 id="查找安装路径"><a href="#查找安装路径" class="headerlink" title="查找安装路径"></a>查找安装路径</h6><pre><code>whereis nginx</code></pre><h4 id="SSL-解决"><a href="#SSL-解决" class="headerlink" title="SSL 解决"></a>SSL 解决</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">很早之前我就在关注 Let&apos;s Encrypt 这个免费、自动化、开放的证书签发服务。它由 ISRG（Internet Security Research Group，互联网安全研究小组）提供服务，而 ISRG 是来自于美国加利福尼亚州的一个公益组织。Let&apos;s Encrypt 得到了 Mozilla、Cisco、Akamai、Electronic Frontier Foundation 和 Chrome 等众多公司和机构的支持，发展十分迅猛。</span><br><span class="line">申请 Let&apos;s Encrypt 证书不但免费，还非常简单，虽然每次只有 90 天的有效期，但可以通过脚本定期更新，配好之后一劳永逸。经过一段时间的观望，我也正式启用 Let&apos;s Encrypt 证书了，本文记录本站申请过程和遇到的问题。</span><br><span class="line">我没有使用 Let&apos;s Encrypt 官网提供的工具来申请证书，而是用了 acme-tiny 这个更为小巧的开源工具。以下内容基本按照 acme-tiny 的说明文档写的，省略了一些我不需要的步骤。</span><br><span class="line">ACME 全称是 Automated Certificate Management Environment，直译过来是自动化证书管理环境的意思，Let&apos;s Encrypt 的证书签发过程使用的就是 ACME 协议。有关 ACME 协议的更多资料可以在这个仓库找到。</span><br><span class="line">创建帐号</span><br><span class="line">首先创建一个目录，例如 ssl，用来存放各种临时文件和最后的证书文件。进入这个目录，创建一个 RSA 私钥用于 Let&apos;s Encrypt 识别你的身份：</span><br><span class="line">openssl genrsa 4096 &gt; account.key</span><br><span class="line">创建 CSR 文件</span><br><span class="line">接着就可以生成 CSR（Certificate Signing Request，证书签名请求）文件了。在这之前，还需要创建域名私钥（一定不要使用上面的账户私钥），根据证书不同类型，域名私钥也可以选择 RSA 和 ECC 两种不同类型。以下两种方式请根据实际情况二选一。</span><br></pre></td></tr></table></figure><h5 id="创建-RSA-私钥（兼容性好）："><a href="#创建-RSA-私钥（兼容性好）：" class="headerlink" title="创建 RSA 私钥（兼容性好）："></a>创建 RSA 私钥（兼容性好）：</h5><pre><code>openssl genrsa 4096 &gt; domain.key</code></pre><h5 id="创建-ECC-私钥（部分老旧操作系统、浏览器不支持。优点是证书体积小）："><a href="#创建-ECC-私钥（部分老旧操作系统、浏览器不支持。优点是证书体积小）：" class="headerlink" title="创建 ECC 私钥（部分老旧操作系统、浏览器不支持。优点是证书体积小）："></a>创建 ECC 私钥（部分老旧操作系统、浏览器不支持。优点是证书体积小）：</h5><pre><code>openssl ecparam -genkey -name secp256r1 | openssl ec -out domain.key# 应该是选择一个就行。#secp384r1openssl ecparam -genkey -name secp384r1 | openssl ec -out domain.key</code></pre><h5 id="生成CSR"><a href="#生成CSR" class="headerlink" title="生成CSR"></a>生成CSR</h5><p>有了私钥文件，就可以生成 CSR 文件了。在 CSR 中推荐至少把域名带 www 和不带 www 的两种情况都加进去，其它子域可以根据需要添加（目前一张证书最多可以包含 100 个域名）：</p><pre><code>openssl req -new -sha256 -key domain.key -subj &quot;/&quot; -reqexts SAN -config &lt;(cat /etc/ssl/openssl.cnf &lt;(printf &quot;[SAN]\nsubjectAltName=DNS:yoursite.com,DNS:www.yoursite.com&quot;)) &gt; domain.csr</code></pre><p>执行这一步时，如果提示找不到 /etc/ssl/openssl.cnf 文件，请看看 /usr/local/openssl/ssl/openssl.cnf 是否存在。如果还是不行，也可以使用交互方式创建 CSR（需要注意 Common Name 必须为你的域名）：</p><pre><code>openssl req -new -sha256 -key domain.key -out domain.csr</code></pre><h5 id="配置验证服务"><a href="#配置验证服务" class="headerlink" title="配置验证服务"></a>配置验证服务</h5><p>我们知道，CA 在签发 DV（Domain Validation）证书时，需要验证域名所有权。传统 CA 的验证方式一般是往 <a href="mailto:admin@yoursite.com" target="_blank" rel="noopener">admin@yoursite.com</a> 发验证邮件，而 Let’s Encrypt 是在你的服务器上生成一个随机验证文件，再通过创建 CSR 时指定的域名访问，如果可以访问则表明你对这个域名有控制权。<br>首先创建用于存放验证文件的目录，例如：</p><pre><code>mkdir ~/www/challenges/</code></pre><p>然后配置一个 HTTP 服务，以 Nginx 为例：</p><pre><code>server{        server_name www.yoursite.com yoursite.com;        location ^~ /.well-known/acme-challenge/ {            alias /home/xxx/www/challenges/;            try_files $uri =404;        }        location / {            rewrite ^/(.*)$ https://yoursite.com/$1 permanent;        }}</code></pre><p>以上配置优先查找 ~/www/challenges/ 目录下的文件，如果找不到就重定向到 HTTPS 地址。这个验证服务以后更新证书还要用到，建议一直保留。</p><h5 id="获取网站证书"><a href="#获取网站证书" class="headerlink" title="获取网站证书"></a>获取网站证书</h5><p>先把 acme-tiny 脚本保存到之前的 ssl 目录：</p><pre><code>wget https://raw.githubusercontent.com/diafygi/acme-tiny/master/acme_tiny.py</code></pre><p>指定账户私钥、CSR 以及验证目录，执行脚本：</p><pre><code>python acme_tiny.py --account-key ./account.key --csr ./domain.csr --acme-dir ~/www/challenges/ &gt; ./signed.crt</code></pre><p>如果一切正常，当前目录下就会生成一个 signed.crt，这就是申请好的证书文件。<br>如果你把域名 DNS 解析放在国内，这一步很可能会遇到类似这样的错误：<br>ValueError: Wrote file to /home/xxx/www/challenges/oJbvpIhkwkBGBAQUklWJXyC8VbWAdQqlgpwUJkgC1Vg, but couldn’t download <a href="http://www.yoursite.com/.well-known/acme-challenge/oJbvpIhkwkBGBAQUklWJXyC8VbWAdQqlgpwUJkgC1Vg" target="_blank" rel="noopener">http://www.yoursite.com/.well-known/acme-challenge/oJbvpIhkwkBGBAQUklWJXyC8VbWAdQqlgpwUJkgC1Vg</a></p><p>这是因为你的域名很可能在国外无法解析，可以找台国外 VPS 验证下。我的域名最近从 DNSPod 换到了阿里云解析，最后又换到了 CloudXNS，就是因为最近前两家在国外都很不稳定。如果你也遇到了类似情况，可以暂时使用国外的 DNS 解析服务商，例如 dns.he.net。如果还是搞不定，也可以试试「Neilpang/le」这个工具的 DNS Mode。<br>搞定网站证书后，还要下载 Let’s Encrypt 的中间证书。我在之前的文章中讲过，配置 HTTPS 证书时既不要漏掉中间证书，也不要包含根证书。在 Nginx 配置中，需要把中间证书和网站证书合在一起：</p><pre><code>wget -O - https://letsencrypt.org/certs/lets-encrypt-x3-cross-signed.pem &gt; intermediate.pemcat signed.crt intermediate.pem &gt; chained.pem</code></pre><p>为了后续能顺利启用 OCSP Stapling，我们再把根证书和中间证书合在一起：</p><pre><code>wget -O - https://letsencrypt.org/certs/isrgrootx1.pem &gt; root.pemcat intermediate.pem root.pem &gt; full_chained.pem</code></pre><p>最终，修改 Nginx 中有关证书的配置并 reload 服务即可：</p><pre><code>ssl_certificate     ~/www/ssl/chained.pem;ssl_certificate_key ~/www/ssl/domain.key;</code></pre><p>Nginx 中与 HTTPS 有关的配置项很多，这里不一一列举了。如有需要，请参考本站配置。</p><h5 id="配置自动更新"><a href="#配置自动更新" class="headerlink" title="配置自动更新"></a>配置自动更新</h5><p>Let’s Encrypt 签发的证书只有 90 天有效期，推荐使用脚本定期更新。例如我就创建了一个 renew_cert.sh 并通过 chmod a+x renew_cert.sh 赋予执行权限。文件内容如下：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span>!/bin/bash</span><br><span class="line"></span><br><span class="line">cd /home/xxx/www/ssl/</span><br><span class="line">python acme_tiny.py --account-key account.key --csr domain.csr --acme-dir /home/xxx/www/challenges/ &gt; signed.crt || exit</span><br><span class="line">wget -O - https://letsencrypt.org/certs/lets-encrypt-x3-cross-signed.pem &gt; intermediate.pem</span><br><span class="line">cat signed.crt intermediate.pem &gt; chained.pem</span><br><span class="line">service nginx reload</span><br><span class="line"></span><br><span class="line">crontab 中使用绝对路径比较保险，crontab -e 加入以下内容：</span><br><span class="line">0 0 1 * * /home/xxx/shell/renew_cert.sh &gt;/dev/null 2&gt;&amp;1</span><br></pre></td></tr></table></figure></p><p>这样以后证书每个月都会自动更新，一劳永逸。实际上，Let’s Encrypt 官方将证书有效期定为 90 天一方面是为了更安全，更重要的是鼓励用户采用自动化部署方案。</p>]]></content>
      
      
      <categories>
          
          <category> Nginx </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Nginx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Jetbrains license搭建</title>
      <link href="/2018/05/15/Jetbrains-license%E6%90%AD%E5%BB%BA/"/>
      <url>/2018/05/15/Jetbrains-license%E6%90%AD%E5%BB%BA/</url>
      
        <content type="html"><![CDATA[<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=410654865&auto=1&height=66"></iframe><h5 id="18-8-30-更新"><a href="#18-8-30-更新" class="headerlink" title="18.8.30 更新"></a>18.8.30 更新</h5><pre><code>该方式已不支持在2018.2.*以上版本。请谨慎升级。</code></pre><blockquote><p>IDEA 全称IntelliJ IDEA，是java语言开发的集成环境，IntelliJ在业界被公认为最好的java开发工具之一，尤其在智能代码助手、代码自动提示、重构、J2EE支持、Ant、JUnit、CVS整合、代码审查、 创新的GUI设计等方面的功能可以说是超常的。</p></blockquote><h4 id="ilanyu’s-Blog"><a href="#ilanyu’s-Blog" class="headerlink" title="ilanyu’s Blog"></a>ilanyu’s Blog</h4><p><a href="http://blog.lanyus.com/archives/174.html" target="_blank" rel="noopener">ilanyu’s</a><br>在github有操作方法。或者看本博客。</p><h4 id="初次使用。"><a href="#初次使用。" class="headerlink" title="初次使用。"></a>初次使用。</h4><p>‘wget –no-check-certificate -O install.sh <a href="https://raw.githubusercontent.com/yushangcl/JetbrainsServer/master/install.sh" target="_blank" rel="noopener">https://raw.githubusercontent.com/yushangcl/JetbrainsServer/master/install.sh</a> &amp;&amp; chmod +x install.sh &amp;&amp; bash install.sh’</p><h4 id="再次使用直接运行install-sh就行了。"><a href="#再次使用直接运行install-sh就行了。" class="headerlink" title="再次使用直接运行install.sh就行了。"></a>再次使用直接运行install.sh就行了。</h4><p>可以打开install.sh配置端口和其他项。</p>]]></content>
      
      
      <categories>
          
          <category> CentOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CentOS 服务搭建 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SSH 免密钥登录</title>
      <link href="/2018/05/04/SSH-%E5%85%8D%E5%AF%86%E9%92%A5%E7%99%BB%E5%BD%95/"/>
      <url>/2018/05/04/SSH-%E5%85%8D%E5%AF%86%E9%92%A5%E7%99%BB%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=247416&auto=1&height=66"></iframe><h4 id="SSH免密钥登录"><a href="#SSH免密钥登录" class="headerlink" title="SSH免密钥登录"></a>SSH免密钥登录</h4><blockquote><p>A为本地主机(即用于控制其他主机的机器,jenkins服务器) ;</p></blockquote><blockquote><p>B为远程主机(即被控制的机器Server，jenkins运行之后发布项目的服务器), 假如ip为192.168.1.100 ;</p></blockquote><blockquote><p>A和B的系统都是Linux</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">在A上的命令:</span><br><span class="line">1、 ssh-keygen -t rsa (连续三次回车,即在本地生成了公钥和私钥,不设置密码)</span><br><span class="line">2、 ssh root@192.168.1.100 &quot;mkdir .ssh;chmod 0700 .ssh&quot; (需要输入密码， 注:必须将.ssh的权限设为700)，如果提示.ssh已经存在，直接ssh root@192.168.1.100  &quot;chmod 0700 .ssh&quot;</span><br><span class="line">3、scp ~/.ssh/id_rsa.pub root@192.168.1.100:.ssh/id_rsa.pub (需要输入密码)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">在B上的命令:</span><br><span class="line">4、 touch /root/.ssh/authorized_keys (如果已经存在这个文件, 跳过这条)</span><br><span class="line">5、 chmod 600 ~/.ssh/authorized_keys  (# 注意： 必须将~/.ssh/authorized_keys的权限改为600, 该文件用于保存ssh客户端生成的公钥，可以修改服务器的ssh服务端配置文件/etc/ssh/sshd_config来指定其他文件名）</span><br><span class="line">6、cat /root/.ssh/id_rsa.pub  &gt;&gt; /root/.ssh/authorized_keys (将id_rsa.pub的内容追加到 authorized_keys 中, 注意不要用，否则会清空原有的内容，使其他人无法使用原有的密钥登录)</span><br><span class="line">7、回到A机器:  ssh root@192.168.1.100 (不需要密码, 登录成功)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> CentOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CentOS 服务搭建 </tag>
            
            <tag> SSH </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Jenkins 自动构建maven项目</title>
      <link href="/2018/05/04/Jenkins-%E8%87%AA%E5%8A%A8%E6%9E%84%E5%BB%BAmaven%E9%A1%B9%E7%9B%AE/"/>
      <url>/2018/05/04/Jenkins-%E8%87%AA%E5%8A%A8%E6%9E%84%E5%BB%BAmaven%E9%A1%B9%E7%9B%AE/</url>
      
        <content type="html"><![CDATA[<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=247415&auto=1&height=66"></iframe><blockquote><p>Jenkins是一个开源软件项目，是基于Java开发的一种持续集成工具，用于监控持续重复的工作，旨在提供一个开放易用的软件平台，使软件的持续集成变成可能。</p></blockquote><h4 id="1-Jenkins安装构建Maven项目时必要的插件。"><a href="#1-Jenkins安装构建Maven项目时必要的插件。" class="headerlink" title="1. Jenkins安装构建Maven项目时必要的插件。"></a>1. Jenkins安装构建Maven项目时必要的插件。</h4><blockquote><p>jenkins 》 系统管理 》 插件管理 》 可选插件 》 输入搜索安装</p></blockquote><p><code>publish over SSH</code> <code>Maven Integration plugin</code></p><h4 id="2-配置项目构建需要的工具。"><a href="#2-配置项目构建需要的工具。" class="headerlink" title="2. 配置项目构建需要的工具。"></a>2. 配置项目构建需要的工具。</h4><blockquote><p>jenkins 》 系统管理 》 全局工具管理</p></blockquote><p>配置jdk   maven   git 路径就可以。</p><img src="/2018/05/04/Jenkins-自动构建maven项目/2.png" title="工具地址"><img src="/2018/05/04/Jenkins-自动构建maven项目/3.png" title="工具地址"><h4 id="3-配置ssh-server信息。用于构建完成执行远程命令。"><a href="#3-配置ssh-server信息。用于构建完成执行远程命令。" class="headerlink" title="3. 配置ssh server信息。用于构建完成执行远程命令。"></a>3. 配置ssh server信息。用于构建完成执行远程命令。</h4><blockquote><p>jenkins 》 系统管理 》 系统设置 》 应该是最底下。直接拉到最底下，如下图配置自己的信息。</p></blockquote><img src="/2018/05/04/Jenkins-自动构建maven项目/6.png" title="配置ssh"><h4 id="4-创建一个新任务。"><a href="#4-创建一个新任务。" class="headerlink" title="4. 创建一个新任务。"></a>4. 创建一个新任务。</h4><img src="/2018/05/04/Jenkins-自动构建maven项目/1.png" title="创建任务"><h4 id="5-配置源码位置。"><a href="#5-配置源码位置。" class="headerlink" title="5. 配置源码位置。"></a>5. 配置源码位置。</h4><img src="/2018/05/04/Jenkins-自动构建maven项目/4.png" title="源码位置"><h4 id="6-构建命令设置。"><a href="#6-构建命令设置。" class="headerlink" title="6. 构建命令设置。"></a>6. 构建命令设置。</h4><img src="/2018/05/04/Jenkins-自动构建maven项目/5.png" title="构建命令"><h4 id="7-配置完成后操作。"><a href="#7-配置完成后操作。" class="headerlink" title="7. 配置完成后操作。"></a>7. 配置完成后操作。</h4><blockquote><p>ssh 免密登录: <a href="/2018/05/04/SSH-免密钥登录/" title="SSH 免密钥登录">SSH 免密钥登录</a> 。</p></blockquote><pre><code>1.先将自己的jar或者war传至远程目录。2.ssh执行command 或者 在远程服务器新建 shell命令文件。直接执行。</code></pre><img src="/2018/05/04/Jenkins-自动构建maven项目/7.png" title="配置"><h4 id="8-扩展——基于webhook实现自动化构建。"><a href="#8-扩展——基于webhook实现自动化构建。" class="headerlink" title="8. 扩展——基于webhook实现自动化构建。"></a>8. 扩展——基于webhook实现自动化构建。</h4><blockquote><p>1.jenkins 搜索并安装插件 : Gogs</p></blockquote><blockquote><p>2.jenkins 任务管理，配置密匙。</p></blockquote><img src="/2018/05/04/Jenkins-自动构建maven项目/8.png" title="配置">    <blockquote><p>3.gogs配置web钩子。 </p></blockquote><img src="/2018/05/04/Jenkins-自动构建maven项目/9.png" title="配置"> ]]></content>
      
      
      <categories>
          
          <category> CentOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CentOS 服务搭建 </tag>
            
            <tag> Jenkins 使用 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Jenkins使用</title>
      <link href="/2018/04/18/Jenkins%E4%BD%BF%E7%94%A8/"/>
      <url>/2018/04/18/Jenkins%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<p><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=25638632&auto=1&height=66"></iframe><br>大学时候偶然听到这首歌，视频不错。</p><h4 id="1-新建用户"><a href="#1-新建用户" class="headerlink" title="1. 新建用户"></a>1. 新建用户</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">useradd jenkins</span><br><span class="line">passwd jenkins</span><br></pre></td></tr></table></figure><h4 id="2-安装jdk1-8"><a href="#2-安装jdk1-8" class="headerlink" title="2. 安装jdk1.8"></a>2. 安装jdk1.8</h4><p>安装教程：<a href="/2018/04/18/JDK安装/" title="JDK安装">JDK安装</a></p><h4 id="3-用jenkins用户安装tomcat8"><a href="#3-用jenkins用户安装tomcat8" class="headerlink" title="3. 用jenkins用户安装tomcat8"></a>3. 用jenkins用户安装tomcat8</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">wget http://124.205.69.162/files/A0460000056AFFBC/mirror.bit.edu.cn/apache/tomcat/tomcat-8/v8.5.14/bin/apache-tomcat-8.5.14.tar.gz</span><br><span class="line">tar -zxvf apache-tomcat-8.5.14.tar.gz</span><br></pre></td></tr></table></figure><h4 id="4-安装git和maven-（不要安装maven3-5版本，有冲突），我用的root用户"><a href="#4-安装git和maven-（不要安装maven3-5版本，有冲突），我用的root用户" class="headerlink" title="4. 安装git和maven.（不要安装maven3.5版本，有冲突），我用的root用户"></a>4. 安装git和maven.（不要安装maven3.5版本，有冲突），我用的root用户</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">一、上传maven包，并解压。（tar -zxvf）</span><br><span class="line">二、修改maven的setting配置文件。</span><br><span class="line">三、将maven安装路径放入环境变量。</span><br><span class="line">四、yum install git。安装git</span><br></pre></td></tr></table></figure><h4 id="5-下载Jenkins并上传至tomcat的webapps目录下"><a href="#5-下载Jenkins并上传至tomcat的webapps目录下" class="headerlink" title="5. 下载Jenkins并上传至tomcat的webapps目录下"></a>5. 下载Jenkins并上传至tomcat的webapps目录下</h4><p> 将Jenkins.war上传至Jenkins的tomcat下。然后启动。<br> <a href="https://jenkins.io/download/" target="_blank" rel="noopener">Jenkins下载</a></p><h4 id="6-开放tomcat端口。启动完成后地址栏访问Jenkins"><a href="#6-开放tomcat端口。启动完成后地址栏访问Jenkins" class="headerlink" title="6. 开放tomcat端口。启动完成后地址栏访问Jenkins."></a>6. 开放tomcat端口。启动完成后地址栏访问Jenkins.</h4><img src="/2018/04/18/Jenkins使用/1.png" title="启动完成"><p>出现上图，表示启动成功。</p><h4 id="7-根据提示，在用户下找这个文件，将文件中字符串复制入输入框即可。"><a href="#7-根据提示，在用户下找这个文件，将文件中字符串复制入输入框即可。" class="headerlink" title="7. 根据提示，在用户下找这个文件，将文件中字符串复制入输入框即可。"></a>7. 根据提示，在用户下找这个文件，将文件中字符串复制入输入框即可。</h4><img src="/2018/04/18/Jenkins使用/2.png" title="输入密匙"><h4 id="8-安装插件-。新手选择推荐安装即可。反之随意。"><a href="#8-安装插件-。新手选择推荐安装即可。反之随意。" class="headerlink" title="8. 安装插件 。新手选择推荐安装即可。反之随意。"></a>8. 安装插件 。新手选择推荐安装即可。反之随意。</h4><img src="/2018/04/18/Jenkins使用/3.png" title="安装插件"><h4 id="9-等待安装完成。新建用户。"><a href="#9-等待安装完成。新建用户。" class="headerlink" title="9. 等待安装完成。新建用户。"></a>9. 等待安装完成。新建用户。</h4><img src="/2018/04/18/Jenkins使用/4.png" title="新建一个用户"><p>然后就可以根据自己的需求下载插件使用了。</p>]]></content>
      
      
      <categories>
          
          <category> CentOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CentOS 服务搭建 </tag>
            
            <tag> Jenkins 使用 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CentOS 搭建 nexus 私服</title>
      <link href="/2018/04/18/CentOS-%E6%90%AD%E5%BB%BA-nexus-%E7%A7%81%E6%9C%8D/"/>
      <url>/2018/04/18/CentOS-%E6%90%AD%E5%BB%BA-nexus-%E7%A7%81%E6%9C%8D/</url>
      
        <content type="html"><![CDATA[<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=27646196&auto=1&height=66"></iframe><h4 id="1-安装JDK"><a href="#1-安装JDK" class="headerlink" title="1. 安装JDK."></a>1. 安装JDK.</h4><p>安装教程：<a href="/2018/04/18/JDK安装/" title="JDK安装">JDK安装</a></p><h4 id="2-推荐新建nexus用户管理nexus。"><a href="#2-推荐新建nexus用户管理nexus。" class="headerlink" title="2. 推荐新建nexus用户管理nexus。"></a>2. 推荐新建nexus用户管理nexus。</h4><pre><code>adduser nexuspasswd nexussu - nexus</code></pre><h4 id="3-下载nexus。本文nexus版本：2-14-8-01-下载地址"><a href="#3-下载nexus。本文nexus版本：2-14-8-01-下载地址" class="headerlink" title="3. 下载nexus。本文nexus版本：2.14.8-01  下载地址"></a>3. 下载nexus。本文nexus版本：2.14.8-01  <a href="https://www.sonatype.com/download-sonatype-trial" target="_blank" rel="noopener">下载地址</a></h4><img src="/2018/04/18/CentOS-搭建-nexus-私服/01.png" title="下载地址"><p>或者直接下载 <code>wget https://sonatype-download.global.ssl.fastly.net/nexus/oss/nexus-2.14.1-01-bundle.tar.gz</code></p><h4 id="4-解压文件：tar-zxvf-nexus文件"><a href="#4-解压文件：tar-zxvf-nexus文件" class="headerlink" title="4. 解压文件：tar -zxvf nexus文件"></a>4. 解压文件：<code>tar -zxvf nexus文件</code></h4><img src="/2018/04/18/CentOS-搭建-nexus-私服/02.png" title="解压"><p>第一个文件夹是核心文件，第二个文件夹用来存储下载下来的jar。<br><img src="/2018/04/18/CentOS-搭建-nexus-私服/03.png" title="文件夹"></p><h4 id="5-进入nexus-nexus-2-14-8-01-conf目录下，编辑nexus-properties文件，命令：vim-nexus-properties"><a href="#5-进入nexus-nexus-2-14-8-01-conf目录下，编辑nexus-properties文件，命令：vim-nexus-properties" class="headerlink" title="5. 进入nexus/nexus-2.14.8-01/conf目录下，编辑nexus.properties文件，命令：vim nexus.properties"></a>5. 进入nexus/nexus-2.14.8-01/conf目录下，编辑nexus.properties文件，命令：<code>vim nexus.properties</code></h4><img src="/2018/04/18/CentOS-搭建-nexus-私服/04.png" title="修改配置文件"><h4 id="6-进入nexus-nexus-2-14-8-01-bin目录，vim-nexus，修改启动用户。"><a href="#6-进入nexus-nexus-2-14-8-01-bin目录，vim-nexus，修改启动用户。" class="headerlink" title="6. 进入nexus/nexus-2.14.8-01/bin目录，vim nexus，修改启动用户。"></a>6. 进入nexus/nexus-2.14.8-01/bin目录，<code>vim nexus</code>，修改启动用户。</h4><img src="/2018/04/18/CentOS-搭建-nexus-私服/05.png" title="修改启动用户"><h4 id="7-启动nexus-nexus-start"><a href="#7-启动nexus-nexus-start" class="headerlink" title="7. 启动nexus  ./nexus start"></a>7. 启动nexus  <code>./nexus start</code></h4><h4 id="8-访问nexus-地址-端口-nexus"><a href="#8-访问nexus-地址-端口-nexus" class="headerlink" title="8. 访问nexus  地址:端口/nexus"></a>8. 访问nexus  <code>地址:端口/nexus</code></h4><img src="/2018/04/18/CentOS-搭建-nexus-私服/06.png" title="index"><p>搭建完成。</p><h4 id="9-maven-settings-xml文件修改。"><a href="#9-maven-settings-xml文件修改。" class="headerlink" title="9. maven settings.xml文件修改。"></a>9. maven settings.xml文件修改。</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--一、localRepository--&gt;</span></span><br></pre></td></tr></table></figure><img src="/2018/04/18/CentOS-搭建-nexus-私服/07.png" title="localRepository"><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--二、mirrors下新建mirror地址--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mirror</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">id</span>&gt;</span>internal-repository<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">name</span>&gt;</span>Maven Repository Manager running on www.ctfo.com<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://你的私服地址/nexus/content/groups/public/<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">mirrorOf</span>&gt;</span>*<span class="tag">&lt;/<span class="name">mirrorOf</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mirror</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--三、maven项目 deploey jar文件。（IDE）--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--在maven settings.xml文件，新增server配置。--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">server</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">id</span>&gt;</span>thirdparty<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">username</span>&gt;</span>admin<span class="tag">&lt;/<span class="name">username</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">password</span>&gt;</span>admin123<span class="tag">&lt;/<span class="name">password</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">server</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--在项目pom文件加--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">distributionManagement</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">repository</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span>&gt;</span>thirdparty<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>nexus<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://你的私服地址/nexus/content/repositories/thirdparty/<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">repository</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">distributionManagement</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--然后deploey就到了第三方库。--&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> CentOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CentOS 服务搭建 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JDK安装</title>
      <link href="/2018/04/18/JDK%E5%AE%89%E8%A3%85/"/>
      <url>/2018/04/18/JDK%E5%AE%89%E8%A3%85/</url>
      
        <content type="html"><![CDATA[<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=247421&auto=1&height=66"></iframe><p>注意。rpm包必须在官网或其他地址下载。直接wget 官网下载链接会报错。</p><h4 id="1-这里采用rpm安装方式。先下载rpm文件。"><a href="#1-这里采用rpm安装方式。先下载rpm文件。" class="headerlink" title="1. 这里采用rpm安装方式。先下载rpm文件。"></a>1. 这里采用rpm安装方式。先下载rpm文件。</h4><h4 id="2-下载到本地，通过shell使用rz命令上传至服务器。"><a href="#2-下载到本地，通过shell使用rz命令上传至服务器。" class="headerlink" title="2. 下载到本地，通过shell使用rz命令上传至服务器。"></a>2. 下载到本地，通过shell使用rz命令上传至服务器。</h4><pre><code>如果出现如下错误：`-bash: rz: command not found`安装lrzsz：`yum -y install lrzsz`现在就可以正常使用rz、sz命令上传、下载数据了。使用方法：上传文件: rz 会弹出对话框，选择文件上传</code></pre><h4 id="3-上传完成之后，执行命令rpm-ivh-您的jdk包。等待安装完成。安装完成之后，路径在-usr-java-下。"><a href="#3-上传完成之后，执行命令rpm-ivh-您的jdk包。等待安装完成。安装完成之后，路径在-usr-java-下。" class="headerlink" title="3. 上传完成之后，执行命令rpm -ivh 您的jdk包。等待安装完成。安装完成之后，路径在/usr/java/下。"></a>3. 上传完成之后，执行命令<code>rpm -ivh 您的jdk包</code>。等待安装完成。安装完成之后，路径在<code>/usr/java/</code>下。</h4><h4 id="4-配置环境变量。vim-etp-profile"><a href="#4-配置环境变量。vim-etp-profile" class="headerlink" title="4. 配置环境变量。vim /etp/profile"></a>4. 配置环境变量。<code>vim /etp/profile</code></h4><pre><code>在文件最下方加入：JAVA_HOME=/usr/java/jdk1.8.0_151JRE_HOME=/usr/java/jdk1.8.0_151/jreCLASS_PATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar:$JRE_HOME/libPATH=$PATH:$JAVA_HOME/bin:$JRE_HOME/binexport PATH</code></pre><h4 id="5-验证是否配置完成。java-version"><a href="#5-验证是否配置完成。java-version" class="headerlink" title="5. 验证是否配置完成。java -version"></a>5. 验证是否配置完成。<code>java -version</code></h4>]]></content>
      
      
      <categories>
          
          <category> CentOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CentOS 服务搭建 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>本站 Next 主题的一些配置</title>
      <link href="/2018/03/16/Next-%E4%B8%BB%E9%A2%98%E7%9A%84%E4%B8%80%E4%BA%9B%E9%85%8D%E7%BD%AE/"/>
      <url>/2018/03/16/Next-%E4%B8%BB%E9%A2%98%E7%9A%84%E4%B8%80%E4%BA%9B%E9%85%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<p>主题的配置。该博客使用Next主题。首先安装主题，在跟目录下运行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/theme-next/hexo-theme-next themes/next</span><br></pre></td></tr></table></figure><p>   然后使用主题，在根目录_config.yml配置文件中，找到theme。修改为<code>next</code>。设置语言为 <code>language: zh-CN</code>;注意不是<code>themes/next/_config.yml</code></p><h4 id="1-目前-NexT-支持的语言如以下表格所示："><a href="#1-目前-NexT-支持的语言如以下表格所示：" class="headerlink" title="1. 目前 NexT 支持的语言如以下表格所示："></a>1. 目前 NexT 支持的语言如以下表格所示：</h4><table><thead><tr><th style="text-align:center">语言</th><th style="text-align:center">代码</th><th style="text-align:center">设定实例</th></tr></thead><tbody><tr><td style="text-align:center">English</td><td style="text-align:center">en</td><td style="text-align:center">language: en</td></tr><tr><td style="text-align:center">简体中文</td><td style="text-align:center">zh-Hans</td><td style="text-align:center">language: zh-Hans</td></tr><tr><td style="text-align:center">Français</td><td style="text-align:center">fr-FR</td><td style="text-align:center">language: fr-FR</td></tr><tr><td style="text-align:center">Português</td><td style="text-align:center">pt</td><td style="text-align:center">language: pt</td></tr><tr><td style="text-align:center">繁體中文</td><td style="text-align:center">zh-hk 或者 zh-tw</td><td style="text-align:center">language: zh-hk</td></tr><tr><td style="text-align:center">Русский язык</td><td style="text-align:center">ru</td><td style="text-align:center">language: ru</td></tr><tr><td style="text-align:center">Deutsch</td><td style="text-align:center">de</td><td style="text-align:center">language: de</td></tr><tr><td style="text-align:center">日本語</td><td style="text-align:center">ja</td><td style="text-align:center">language: ja</td></tr><tr><td style="text-align:center">Indonesian</td><td style="text-align:center">id</td><td style="text-align:center">language: id</td></tr></tbody></table><h4 id="2-菜单管理"><a href="#2-菜单管理" class="headerlink" title="2. 菜单管理"></a>2. 菜单管理</h4><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">menu:</span></span><br><span class="line"><span class="attr">  home:</span> <span class="string">首页</span></span><br><span class="line"><span class="attr">  archives:</span> <span class="string">归档</span></span><br><span class="line"><span class="attr">  categories:</span> <span class="string">分类</span></span><br><span class="line"><span class="attr">  tags:</span> <span class="string">标签</span></span><br><span class="line"><span class="attr">  about:</span> <span class="string">关于</span></span><br><span class="line"><span class="attr">  search:</span> <span class="string">搜索</span></span><br><span class="line"><span class="attr">  commonweal:</span> <span class="string">公益404</span></span><br><span class="line"><span class="attr">  something:</span> <span class="string">有料</span></span><br></pre></td></tr></table></figure><h4 id="3-设定对应菜单项的图标，对应的字段是-menu-icons。-此设定格式是-item-name-icon-name，"><a href="#3-设定对应菜单项的图标，对应的字段是-menu-icons。-此设定格式是-item-name-icon-name，" class="headerlink" title="3. 设定对应菜单项的图标，对应的字段是 menu_icons。 此设定格式是 item name: icon name，"></a>3. 设定对应菜单项的图标，对应的字段是 menu_icons。 此设定格式是 <code>item name: icon name</code>，</h4><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">menu_icons:</span></span><br><span class="line"><span class="attr">  enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="comment"># Icon Mapping.</span></span><br><span class="line"><span class="attr">  home:</span> <span class="string">home</span></span><br><span class="line"><span class="attr">  about:</span> <span class="string">user</span></span><br><span class="line"><span class="attr">  categories:</span> <span class="string">th</span></span><br><span class="line"><span class="attr">  tags:</span> <span class="string">tags</span></span><br><span class="line"><span class="attr">  archives:</span> <span class="string">archive</span></span><br><span class="line"><span class="attr">  commonweal:</span> <span class="string">heartbeat</span></span><br></pre></td></tr></table></figure><h4 id="4-启动页面浏览量功能。这里使用的是leancloud。在leancloud官网获取AppID-and-AppKey。"><a href="#4-启动页面浏览量功能。这里使用的是leancloud。在leancloud官网获取AppID-and-AppKey。" class="headerlink" title="4. 启动页面浏览量功能。这里使用的是leancloud。在leancloud官网获取AppID and AppKey。"></a>4. 启动页面浏览量功能。这里使用的是<code>leancloud</code>。在<a href="https://leancloud.cn" target="_blank" rel="noopener">leancloud</a>官网获取AppID and AppKey。</h4><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">leancloud_visitors:</span></span><br><span class="line"><span class="attr">   enable:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">   app_id:</span> <span class="string">yourappid</span> <span class="comment">#&lt;app_id&gt;</span></span><br><span class="line"><span class="attr">   app_key:</span> <span class="string">yourappkey</span> <span class="comment">#&lt;app_key&gt;</span></span><br></pre></td></tr></table></figure><h4 id="5-文章评论系统。这里使用的是来必力。第一次使用直接按照套路注册就可以。然后使用免费的City版本，"><a href="#5-文章评论系统。这里使用的是来必力。第一次使用直接按照套路注册就可以。然后使用免费的City版本，" class="headerlink" title="5. 文章评论系统。这里使用的是来必力。第一次使用直接按照套路注册就可以。然后使用免费的City版本，"></a>5. 文章评论系统。这里使用的是来必力。第一次使用直接按照套路注册就可以。然后使用免费的City版本，</h4>  <img src="/2018/03/16/Next-主题的一些配置/next1.jpg" title="安装图示"><p>  点击现在安装，出现如下界面。</p>  <img src="/2018/03/16/Next-主题的一些配置/next2.jpg" title="安装图示"><p>  复制其中的uid字段。打开主题目录下的 <code>blog/themes/next/_config.yml</code> 配置文件，定位到 livere_uid 字段，粘贴上刚刚复制的UID。至此，大功告成。</p><h4 id="6-添加文章分享功能。这里使用AddThis。可以选择样式和哪里分享，很不错。"><a href="#6-添加文章分享功能。这里使用AddThis。可以选择样式和哪里分享，很不错。" class="headerlink" title="6. 添加文章分享功能。这里使用AddThis。可以选择样式和哪里分享，很不错。"></a>6. 添加文章分享功能。这里使用AddThis。可以选择样式和哪里分享，很不错。</h4>  <img src="/2018/03/16/Next-主题的一些配置/next1.png" title="分享展示"><p>  注册账号，慢慢弄，根据喜好，找自己喜欢的样式。注册后找到该位置。</p>  <img src="/2018/03/16/Next-主题的一些配置/next3.jpg"><p>  在主题配置文件中搜索add_this_id，去掉前面的注释，添加上你的AddThis ID就可以了。</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># Share  分享</span><br><span class="line">#jiathis: true</span><br><span class="line"># Warning: JiaThis does not support https. 博主实测支持https</span><br><span class="line">add_this_id: &#123;your AddThis ID&#125;</span><br></pre></td></tr></table></figure><h4 id="7-打开文章后侧边栏目录显示问题"><a href="#7-打开文章后侧边栏目录显示问题" class="headerlink" title="7. 打开文章后侧边栏目录显示问题"></a>7. 打开文章后侧边栏目录显示问题</h4>  <img src="/2018/03/16/Next-主题的一些配置/next2.png" title="分享展示"><p>  number为true时自动排号。</p><h4 id="8-修改fonts-googleapis-com加载极慢问题。"><a href="#8-修改fonts-googleapis-com加载极慢问题。" class="headerlink" title="8. 修改fonts.googleapis.com加载极慢问题。"></a>8. 修改fonts.googleapis.com加载极慢问题。</h4><p>  在next主题的_config.yml里面找到 <code>host</code> 。然后改为<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># Uri of fonts host. E.g. //fonts.googleapis.com (Default).</span><br><span class="line">host: //fonts.lug.ustc.edu.cn # fonts.lug.ustc.edu.cn是中科大的源。</span><br></pre></td></tr></table></figure></p><h4 id="9-修改第三方JS库"><a href="#9-修改第三方JS库" class="headerlink" title="9. 修改第三方JS库"></a>9. 修改第三方JS库</h4><p>  在主题配置文件中设定成合适的 CDN 地址，此特性可以加速静态资源（JavaScript 第三方库）的加载。</p><p>  例如：<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"># Script Vendors.</span><br><span class="line"># Set a CDN address for the vendor you want to customize.</span><br><span class="line"># For example</span><br><span class="line">#    mquery: https://ajax.googleapis.com/ajax/libs/jquery/2.2.0/jquery.min.js</span><br><span class="line"># Be aware that you should use the same version as internal ones to avoid potential problems.</span><br><span class="line"># Please use the https protocol of CDN files when you enable https on your site.</span><br><span class="line">vendors:</span><br><span class="line">  # Internal path prefix. Please do not edit it.</span><br><span class="line">  _internal: lib</span><br><span class="line">  </span><br><span class="line">  # Internal version: 2.1.3</span><br><span class="line">  jquery: //cdn.jsdelivr.net/jquery/2.1.3/jquery.min.js</span><br><span class="line">  </span><br><span class="line">  # Internal version: 2.1.5</span><br><span class="line">  # See: http://fancyapps.com/fancybox/</span><br><span class="line">  fancybox: //cdn.jsdelivr.net/fancybox/2.1.5/jquery.fancybox.pack.js</span><br><span class="line">  fancybox_css: //cdn.jsdelivr.net/fancybox/2.1.5/jquery.fancybox.min.css</span><br><span class="line">  </span><br><span class="line">  # Internal version: 1.0.6</span><br><span class="line">  # See: https://github.com/ftlabs/fastclick</span><br><span class="line">  fastclick: //cdn.jsdelivr.net/fastclick/1.0.6/fastclick.min.js</span><br><span class="line">  </span><br><span class="line">  # Internal version: 1.9.7</span><br><span class="line">  # See: https://github.com/tuupola/jquery_lazyload</span><br><span class="line">  lazyload: //cdn.jsdelivr.net/jquery.lazyload/1.9.3/jquery.lazyload.min.js</span><br><span class="line">  </span><br><span class="line">  # Internal version: 1.2.1</span><br><span class="line">  # See: http://VelocityJS.org</span><br><span class="line">  velocity: //cdn.jsdelivr.net/velocity/1.2.3/velocity.min.js</span><br><span class="line">  </span><br><span class="line">  # Internal version: 1.2.1</span><br><span class="line">  # See: http://VelocityJS.org</span><br><span class="line">  velocity_ui: //cdn.jsdelivr.net/velocity/1.2.3/velocity.ui.min.js</span><br><span class="line">  </span><br><span class="line">  # Internal version: 0.7.9</span><br><span class="line">  # See: https://faisalman.github.io/ua-parser-js/</span><br><span class="line">  ua_parser: //cdn.jsdelivr.net/ua-parser.js/0.7.10/ua-parser.min.js</span><br><span class="line">  </span><br><span class="line">  # Internal version: 4.6.2</span><br><span class="line">  # See: http://fontawesome.io/</span><br><span class="line">  fontawesome: //maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css</span><br><span class="line">  </span><br><span class="line">  # Internal version: 1</span><br><span class="line">  # https://www.algolia.com</span><br><span class="line">  algolia_instant_js:</span><br><span class="line">  algolia_instant_css:</span><br><span class="line">  </span><br><span class="line">  # Internal version: 1.0.2</span><br><span class="line">  # See: https://github.com/HubSpot/pace</span><br><span class="line">  # Or use direct links below:</span><br><span class="line">  # pace: //cdn.bootcss.com/pace/1.0.2/pace.min.js</span><br><span class="line">  # pace_css: //cdn.bootcss.com/pace/1.0.2/themes/blue/pace-theme-flash.min.css</span><br><span class="line">  pace: //cdn.bootcss.com/pace/1.0.2/pace.min.js</span><br><span class="line">  pace_css: //cdn.bootcss.com/pace/1.0.2/themes/blue/pace-theme-flash.min.css</span><br><span class="line">  </span><br><span class="line">  # Internal version: 1.0.0</span><br><span class="line">  # https://github.com/hustcc/canvas-nest.js</span><br><span class="line">  canvas_nest: //cdn.bootcss.com/canvas-nest.js/1.0.1/canvas-nest.min.js</span><br></pre></td></tr></table></figure></p><h4 id="10-文章末尾统一添加“本文结束”标记"><a href="#10-文章末尾统一添加“本文结束”标记" class="headerlink" title="10. 文章末尾统一添加“本文结束”标记"></a>10. 文章末尾统一添加“本文结束”标记</h4><p>  在路径\themes\next\layout_macro中新建passage-end-tag.swig文件,并添加以下内容：</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">    &#123;% if not is_index %&#125;</span><br><span class="line">        &lt;div style=&quot;text-align:center;color: #555;font-size:14px;&quot;&gt;-------------The End-------------&lt;/div&gt;</span><br><span class="line">    &#123;% endif %&#125;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>  接着打开\themes\next\layout_macro\post.swig文件，在这个位置添加代码：</p>  <img src="/2018/03/16/Next-主题的一些配置/next4.jpg"><p>  要添加的代码如下：</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">  &#123;% if not is_index %&#125;</span><br><span class="line">    &#123;% include &apos;passage-end-tag.swig&apos; %&#125;</span><br><span class="line">  &#123;% endif %&#125;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>  然后打开主题配置文件，在末尾添加：</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 文章末尾添加“本文结束”标记</span><br><span class="line">passage_end_tag:</span><br><span class="line">  enabled: true</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git Windows安装教程</title>
      <link href="/2018/03/15/Git%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/"/>
      <url>/2018/03/15/Git%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<blockquote><p>Git是一个开源的分布式版本控制系统，可以有效、高速的处理从很小到非常大的项目版本管理。Git 是 Linus Torvalds 为了帮助管理 Linux 内核开发而开发的一个开放源码的版本控制软件。</p></blockquote><p>直接下载安装就可以。下载地址：<a href="https://gitforwindows.org/" target="_blank" rel="noopener">Git官网</a></p><h4 id="1-开始安装"><a href="#1-开始安装" class="headerlink" title="1. 开始安装"></a>1. 开始安装</h4><img src="/2018/03/15/Git安装教程/az1.png" title="第一步"><h4 id="2-文件位置存储，可根据自己盘的情况安装"><a href="#2-文件位置存储，可根据自己盘的情况安装" class="headerlink" title="2. 文件位置存储，可根据自己盘的情况安装"></a>2. 文件位置存储，可根据自己盘的情况安装</h4><img src="/2018/03/15/Git安装教程/az2.png" title="第二步"><h4 id="3-安装配置文件，自己需要的都选上，下一步"><a href="#3-安装配置文件，自己需要的都选上，下一步" class="headerlink" title="3. 安装配置文件，自己需要的都选上，下一步"></a>3. 安装配置文件，自己需要的都选上，下一步</h4><img src="/2018/03/15/Git安装教程/az3.png" title="第三步"><h4 id="4-不创建启动文件夹，下一步："><a href="#4-不创建启动文件夹，下一步：" class="headerlink" title="4. 不创建启动文件夹，下一步："></a>4. 不创建启动文件夹，下一步：</h4><img src="/2018/03/15/Git安装教程/az4.png" title="第四步"><h4 id="5-选择默认的编辑器，我们直接用推荐的就行，下一步"><a href="#5-选择默认的编辑器，我们直接用推荐的就行，下一步" class="headerlink" title="5. 选择默认的编辑器，我们直接用推荐的就行，下一步"></a>5. 选择默认的编辑器，我们直接用推荐的就行，下一步</h4><img src="/2018/03/15/Git安装教程/az5.png" title="第五步"><h4 id="6-勾上第二项，这样就可以在cmd中操作，下一步"><a href="#6-勾上第二项，这样就可以在cmd中操作，下一步" class="headerlink" title="6. 勾上第二项，这样就可以在cmd中操作，下一步"></a>6. 勾上第二项，这样就可以在cmd中操作，下一步</h4><img src="/2018/03/15/Git安装教程/az6.png" title="第六步"><h4 id="7-使用默认设置就行，下一步："><a href="#7-使用默认设置就行，下一步：" class="headerlink" title="7. 使用默认设置就行，下一步："></a>7. 使用默认设置就行，下一步：</h4><img src="/2018/03/15/Git安装教程/az7.png" title="第七步"><h4 id="8-配置行结束标记，保持默认“Checkout”"><a href="#8-配置行结束标记，保持默认“Checkout”" class="headerlink" title="8. 配置行结束标记，保持默认“Checkout”"></a>8. 配置行结束标记，保持默认“Checkout”</h4><img src="/2018/03/15/Git安装教程/az8.png" title="第八步"><h4 id="9-在终端模拟器选择页面，默认即可，配置后Git"><a href="#9-在终端模拟器选择页面，默认即可，配置后Git" class="headerlink" title="9. 在终端模拟器选择页面，默认即可，配置后Git"></a>9. 在终端模拟器选择页面，默认即可，配置后Git</h4><img src="/2018/03/15/Git安装教程/az9.png" title="第九步"><h4 id="10-最后配置Git额外选择默认即可，然后安装。"><a href="#10-最后配置Git额外选择默认即可，然后安装。" class="headerlink" title="10. 最后配置Git额外选择默认即可，然后安装。"></a>10. 最后配置Git额外选择默认即可，然后安装。</h4><img src="/2018/03/15/Git安装教程/az10.png" title="第十步"><h4 id="11-安装过程："><a href="#11-安装过程：" class="headerlink" title="11. 安装过程："></a>11. 安装过程：</h4><img src="/2018/03/15/Git安装教程/az11.png" title="第十一步"><h4 id="12-安装完成"><a href="#12-安装完成" class="headerlink" title="12. 安装完成."></a>12. 安装完成.</h4><img src="/2018/03/15/Git安装教程/az12.png" title="安装完成">]]></content>
      
      
      <categories>
          
          <category> 安装教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo 博客搭建</title>
      <link href="/2018/03/15/hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/"/>
      <url>/2018/03/15/hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/</url>
      
        <content type="html"><![CDATA[<p><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=30967201&auto=1&height=66"></iframe><br><img src="/2018/03/15/hexo搭建博客/myBlog.jpg" title="我的博客首页"></p><h4 id="1-安装Git"><a href="#1-安装Git" class="headerlink" title="1. 安装Git"></a>1. 安装Git</h4><p>直接下载安装就可以。下载地址：<a href="https://gitforwindows.org/" target="_blank" rel="noopener">Git官网</a><br>或者，有安装教程：<a href="/2018/03/15/Git安装教程/" title="Git Windows安装教程">Git Windows安装教程</a></p><h4 id="2-安装NodeJS"><a href="#2-安装NodeJS" class="headerlink" title="2. 安装NodeJS"></a>2. 安装NodeJS</h4><p>Hexo是基于nodeJS环境的静态博客，里面的npm工具很有用。而且命令特别简单。</p><ul><li><a href="https://nodejs.org/en/" target="_blank" rel="noopener">下载地址</a>(说明：LTS为长期支持版，Current为当前最新版)</li><li>基本上一路上next就行。注意：Custom Setup中记得选择<code>ADD To Path</code>。这样就不用自己配置环境变量了。不然就和java一样去配置环境变量。</li><li><p>查看版本</p><ul><li><p><code>node -v</code></p><img src="/2018/03/15/hexo搭建博客/node1.png" title="node版本"></li></ul></li></ul><h4 id="3-安装Hexo"><a href="#3-安装Hexo" class="headerlink" title="3. 安装Hexo"></a>3. 安装Hexo</h4><ul><li>创建一个文件夹，用于存放Blog的所有文件。</li><li>Shift+鼠标右键。在该目录打开命令行，然后执行命令：<code>npm i -g hexo</code></li><li><p>安装完成之后查看版本：<code>hexo -v</code></p>  <img src="/2018/03/15/hexo搭建博客/hexo1.png" title="hexo版本"></li><li><p>初始化。<code>hexo init</code>;运行成功，打开文件夹可看到以下文件。</p>  <img src="/2018/03/15/hexo搭建博客/h1.png" title="初始化"></li><li><p>解释一下</p><ul><li>node_modules：是依赖包</li><li>public：存放的是生成的页面</li><li>scaffolds：命令生成文章等的模板</li><li>source：用命令创建的各种文章</li><li>themes：主题</li><li>_config.yml：整个博客的配置</li><li>db.json：source解析所得到的</li><li>package.json：项目所需模块项目的配置信息</li></ul></li></ul><h4 id="4-将项目在-Github-配置"><a href="#4-将项目在-Github-配置" class="headerlink" title="4. 将项目在 Github 配置"></a>4. 将项目在 Github 配置</h4><ul><li>添加一个repo，名称为<code>yourname.github.io</code>,其中yourname是你的github用户名。必须这个规则创建。</li><li><p>开启<code>GitHub Pages</code>。在Setting配置页中，找到这个项，点击Automatic page generator，Github将会自动替你创建出一个gh-pages的页面。 如果你的配置没有问题，那么大约15分钟之后，yourname.github.io这个网址就可以正常访问了~ 如果yourname.github.io已经可以正常访问了，那么Github一侧的配置已经全部结束了。</p>   <img src="/2018/03/15/hexo搭建博客/h2.png" title="生成成功"></li><li><p>然后就是Blog的一些设置了。</p></li></ul><h4 id="5-Hexo-怎么玩。"><a href="#5-Hexo-怎么玩。" class="headerlink" title="5. Hexo 怎么玩。"></a>5. Hexo 怎么玩。</h4><ul><li><p>命令行自动部署blog。此处必须依赖插件。需先安装一波 <code>npm install hexo-deployer-git --save</code>。然后配置_config.xml文件。</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repository:</span><br><span class="line">    github: git@github.com:YangXHero/yangkai.github.io.git</span><br><span class="line">    coding: git@git.coding.net:yangkai92/yangkai92.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure></li><li><p>自定义站点文章搜索。需先安装一波 <code>npm install hexo-generator-search --save</code>。然后配置文件。</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">search:</span><br><span class="line">  path: search.xml</span><br><span class="line">  # 如只想索引文章，可设置为post</span><br><span class="line">  field: all</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>添加RSS。在主题配置文件中有NexT默认的RSS设置，默认为留空，这时使用 Hexo 生成的 Feed 链接，需要先安装 hexo-generator-feed插件。</p><p>在站点根目录打开git bash，安装插件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install --save hexo-generator-feed</span><br></pre></td></tr></table></figure><p>在站点配置文件加以下代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 配置RSS</span><br><span class="line">feed:</span><br><span class="line">  #feed 类型 (atom/rss2)</span><br><span class="line">  type: atom</span><br><span class="line">  #rss 路径</span><br><span class="line">  path: atom.xml</span><br><span class="line">  #在 rss 中最多生成的文章数(0显示所有)</span><br><span class="line">  limit: 0</span><br></pre></td></tr></table></figure><p>修改主题配置文件如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># Set rss to false to disable feed link.</span><br><span class="line"># Leave rss as empty to use site&apos;s feed link.</span><br><span class="line"># Set rss to specific value if you have burned your feed already.</span><br><span class="line">rss: /atom.xml</span><br></pre></td></tr></table></figure></li><li><p>在文章中添加图片信息。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">把主页配置文件_config.yml 里的post_asset_folder:这个选项设置为true</span><br><span class="line">  </span><br><span class="line">在你的hexo目录下执行这样一句话npm install hexo-asset-image --save，</span><br><span class="line">这是下载安装一个可以上传本地图片的插件，来自dalao：dalao的git</span><br><span class="line">  </span><br><span class="line">等待一小段时间后，再运行hexo n &quot;xxxx&quot;来生成md博文时，</span><br><span class="line">/source/_posts文件夹内除了xxxx.md文件还有一个同名的文件夹</span><br><span class="line"></span><br><span class="line">文章中引用。  `&#123;% asset_img 图片名称 图片描述 %&#125;`</span><br></pre></td></tr></table></figure></li></ul><ul><li>常用命令<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1.hexo new 文章名称</span><br><span class="line">2.hexo g  生成静态文件</span><br><span class="line">3.hexo d  部署，发布。</span><br><span class="line">4.hexo clean 清除上次生成的静态文件。</span><br></pre></td></tr></table></figure></li></ul><ul><li>新建标签和分类页面<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">hexo new page tags    </span><br><span class="line">hexo new page categories</span><br><span class="line">  </span><br><span class="line">在页面对应index.md中加相应的type类型。</span><br><span class="line">---</span><br><span class="line">title: tags</span><br><span class="line">date: 2018-08-20 17:31:44</span><br><span class="line">type: &quot;tags&quot;</span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line">title: categories</span><br><span class="line">date: 2018-08-20 17:31:53</span><br><span class="line">type: &quot;categories&quot;</span><br><span class="line">---</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
